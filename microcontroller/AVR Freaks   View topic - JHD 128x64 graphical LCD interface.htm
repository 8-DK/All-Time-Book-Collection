<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" -->
<html dir="ltr">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta http-equiv="Content-Style-Type" content="text/css">
<title>AVR Freaks :: View topic - JHD 128x64 graphical LCD interface</title>
<style type="text/css">
<!--
body {
    font-family: Verdana, Arial, Helvetica, sans-serif;
    font-size: 12px ;
    letter-spacing: 1px;
}
/* Quote & Code blocks */
.code, .quote, .php {
    font-size: 11px;
	border: black; border-style: solid;
	border-left-width: 1px; border-top-width: 1px; border-right-width: 1px; border-bottom-width: 1px
}
.Forum {
    font-weight : bold;
    font-size: 18px;
}
.Topic {
    font-weight : bold;
    font-size: 14px;
}
.genmed {
    font-size: 12px;
}
hr.sep	{ height: 0px; border: solid #D1D7DC 0px; border-top-width: 1px;}
-->
</style>
</head>
<body>
<span class="Forum"><div align="center">AVR Freaks</div></span><br />
<span class="Topic">AVR forum - JHD 128x64 graphical LCD interface</span><br />
<hr />
<b>katochd46</b> - Aug 29, 2010 - 03:52 PM<br />
<b>Post subject: </b>JHD 128x64 graphical LCD interface<hr class="sep"/>
hi new to forum, trying to interface JHD 128x64 graphical LCD to mega16, i am not able to find the detail description related to it. Is there ant reference implemetaion related to it ?
<br />

<br />
earlier i implemented interface for JHD 16x2, it is totally same as HD44780<hr />
<b>Lennart</b> - Aug 29, 2010 - 04:05 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">earlier i implemented interface for JHD 16x2, it is totally same as HD44780</div>
<br />
So now you need to find out what controller chip the JHD 128x64 graphical LCD use, i.e. KS0108<hr />
<b>Lennart</b> - Aug 29, 2010 - 04:13 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
At the bottom of this site you have the answer.
<br />
Google is your friend...
<br />
<!-- m --><a href="http://cgi.ebay.com/Graphic-Matrix-LCD-Module-LCM-JHD-12864-E-128X64-/200392901987" target="_blank">http://cgi.ebay.com/Graphic-Matrix-LCD- ... 0392901987</a><!-- m -->
<br />

<br />
So now you need to search stuff related to that driver and AVR's.<hr />
<b>katochd46</b> - Aug 29, 2010 - 04:31 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
thanks for details, it will be helpful<hr />
<b>david.prentice</b> - Aug 29, 2010 - 04:35 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Google revealed <a href="http://www.jinghua-displays.com/english/sglcm.htm" target="_blank" class="postlink">http://www.jinghua-displays.com/english/sglcm.htm</a>
<br />

<br />
So all you have to do is implement a T6963C or KS0108 library.   The two controllers are vastly different,  but there is plenty of code available for either.
<br />

<br />
David.<hr />
<b>katochd46</b> - Sep 02, 2010 - 04:22 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<a href="http://translate.google.com.sg/translate?hl=en&amp;sl=pl&amp;u=http://radzio.dxp.pl/ks0108/&amp;ei=LI5_TMv8NYGXcZrt3fIK&amp;sa=X&amp;oi=translate&amp;ct=result&amp;resnum=1&amp;ved=0CBgQ7gEwAA&amp;prev=/search%3Fq%3Dhttp://radzio.dxp.pl/ks0108/%26hl%3Den" target="_blank" class="postlink">http://translate.google.com.sg/translate?hl=en&amp;sl=pl&amp;u=http://radzio.dxp.pl/ks0108/&amp;ei=LI5_TMv8NYGXcZrt3fIK&amp;sa=X&amp;oi=translate&amp;ct=result&amp;resnum=1&amp;ved=0CBgQ7gEwAA&amp;prev=/search%3Fq%3Dhttp://radzio.dxp.pl/ks0108/%26hl%3Den</a>
<br />
I am using the above link for tutorial &amp; code reference.
<br />

<br />
<a href="http://translate.googleusercontent.com/translate_c?hl=en&amp;sl=pl&amp;u=http://radzio.dxp.pl/font/&amp;prev=/search%3Fq%3Dhttp://radzio.dxp.pl/ks0108/%26hl%3Den&amp;rurl=translate.google.com.sg&amp;usg=ALkJrhgMihB20JX0XXaFGO-upMyZvAi6lg" target="_blank" class="postlink">http://translate.googleusercontent.com/translate_c?hl=en&amp;sl=pl&amp;u=http://radzio.dxp.pl/font/&amp;prev=/search%3Fq%3Dhttp://radzio.dxp.pl/ks0108/%26hl%3Den&amp;rurl=translate.google.com.sg&amp;usg=ALkJrhgMihB20JX0XXaFGO-upMyZvAi6lg</a>
<br />
This link is used to generate the font for the character 5x8 font size.
<br />

<br />
<a href="http://www.azdisplays.com/PDF/agm1264b.pdf" target="_blank" class="postlink">http://www.azdisplays.com/PDF/agm1264b.pdf</a>
<br />
above link for the command related to G-lcd.
<br />

<br />
Code is bit confusing from the mentioned link so i just want to make my own library.
<br />
As there are two halfs of the g-lcd 128x64 ----- two half 64x64 &amp; 64X64
<br />
Each half there is diff CS signal.
<br />

<br />
As my font is 5*8 size i.e 5 column &amp; 8 rows
<br />
If i have to display &quot;HELLO&quot; in the 0th page it may come in both half.
<br />

<br />
so in this case I am congused with the command, which command i have to give to display H.
<br />
then make my curser to move to move by 5 column to display E(as font size is 5x8).
<br />
then make my curser to move to move by 5 column to display L
<br />
so on .....
<br />

<br />
01xxxxxx ---- set the y address ----- i am confused is it row or column
<br />
10111xxx ----  set the page  - this is clear to me
<br />
11xxxxxx ---- display start line  ----- what is the use of this command 
<br />
                                        
<br />
 
<br />
What is exact sequence of command &amp; which command to use to move my curser ?
<br />

<br />
library on net are very confusing, this is the simplest i found is there any other simple link for further reference?<hr />
<b>clawson</b> - Sep 02, 2010 - 04:44 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
While it's inefficient the following will work:
<br />

<br />
Start by developing a plot_pixel(x,y, 0/1) function that can handle the switch between controllers as x transitions from 63 to 64 (I assume 0,0 base). That's the only place in the entire code that needs to know about the complexity of the two controllers.
<br />

<br />
Write all subsequent graphic primitives (line, circle, rectangle, filled_area, etc) to make use of pixel(x,y, ON/OFF).
<br />

<br />
For fonts you just have a &quot;blit&quot; routine that can take a source rectangle of dimension WxH and start plotting it at (x,y) onwards. It just has nested for() loops that work across W and down/up H calling plot_pixel(X+w, Y+h, state).
<br />

<br />
Now you can blit fonts onto the display - even straddling the controller boundary.
<br />

<br />
The price you pay for this simplicity is the inefficiency of the plotting. In reality the same GRAM byte may be written multiple times as a font entry is blitted to the display. Later on when this simple version works you can look at optimising it so that the GRAM access is more direct.
<br />

<br />
But it gets you started and you learn a lot about the controller in the interim.
<br />

<br />
Cliff<hr />
<b>bobgardner</b> - Sep 02, 2010 - 05:06 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Here is one extra 'layer' to what Cliff suggested..... 128x64 pix is 8k pixels, 1k  bytes. Draw everything into this ram frame buffer pretending its a pc style screen with pixels starting at the top left and going to the right. Then you only need to write a 'copy screen from ram to lcd a byte at a time' routine.<hr />
<b>clawson</b> - Sep 02, 2010 - 05:18 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Actually I like Bob's suggestion better - if you ever want to do &quot;moving&quot; on an LCD you want to use a &quot;back buffer&quot; anyway and blit &quot;behind the line clock&quot; to prevent flicker during updates. It &quot;costs&quot; one RAM buffer of LCD size though - time to buy a 1284P perhaps?<hr />
<b>katochd46</b> - Sep 03, 2010 - 01:31 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Just one more thing :---
<br />

<br />
In hd44780 an autoincrement of the cursor position is possible after displaying an character, does it happens in the case of KS0108 ?
<br />

<br />
means :--
<br />
Suppose I have to display an character 'H', 
<br />
its font is 5x8 -- i.e 8 vertical pixels &amp; 5 horizontal pixels.
<br />

<br />
suppose its value in 5 byte(i.e 5x8) is :--
<br />
0x55, 0x11, 0x22, 0x33, 0x44
<br />

<br />
And if i have set the display line to zero &amp; x-cordinate also to zero.
<br />
Means at present control is at the begining of the G-LCD.
<br />

<br />
Then in this case after sending 0x55, do i have to send an command to increase my x-cordinate by one, to send the next byte 0x11.
<br />

<br />
Is this logic right ?
<br />

<br />
You can refer my code. 
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp;
<br />
void GLCD_WriteChar&#40;char charToWrite&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;int i;
<br />
&nbsp; &nbsp;charToWrite -= 32;&nbsp; &nbsp;// as we are storing assci caracter after 32 only
<br />
&nbsp; &nbsp;for&#40;i = 0; i &lt; 5; i++&#41; 
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ks0108GotoXY&#40;ks0108Coord.x +i , ks0108Coord.y&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;GLCD_WriteData&#40;pgm_read_byte&#40;&#40;char *&#41;&#40;&#40;int&#41;font5x8 + &#40;5 * charToWrite&#41; + i&#41;&#41;&#41;; 
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;/* 
<br />
&nbsp; &nbsp; &nbsp; &nbsp;after displaying one character increase the 
<br />
&nbsp; &nbsp; &nbsp; &nbsp;x cordinate i.e the length by 1 as font is 5 pixel wide
<br />
&nbsp; &nbsp; &nbsp; &nbsp;already increased in above for loop
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &amp; 1 pixel left between the lines
<br />
&nbsp; &nbsp;*/
<br />
&nbsp; &nbsp;ks0108GotoXY&#40;ks0108Coord.x +i , ks0108Coord.y&#41;;
<br />
&nbsp; &nbsp;GLCD_WriteData&#40;0x00&#41;;
<br />
&#125;</div><hr />
<b>clawson</b> - Sep 03, 2010 - 02:26 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
does it happens in the case of KS0108 ? 
<br />
</div>
<br />
A KS0108 does not have &quot;character cells&quot;. It is simply a &quot;sea&quot; of pixels. Tracking cursor position is something you have to do. If your font is 5 pixels wide then YOU have to add 5 (possibly 6 depending on whether they have an inter-character space) onto X after each blit.<hr />
<b>bobgardner</b> - Sep 03, 2010 - 02:37 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Blit -&gt; Bit Block Transfer which is graphics speak for 'copy a 5x7 character from here to there by reading and setting 35 pixels in a pair of nested loops'.<hr />
<b>DocJC</b> - Sep 03, 2010 - 02:49 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
And don't forget to &quot;Turn On&quot; the display as part of initializing it.
<br />

<br />
JC<hr />
<b>clawson</b> - Sep 03, 2010 - 03:04 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
&quot;Turn On&quot; the display 
<br />
</div>
<br />
What does that involve? You give it a box of chocolates and tell it you'll always love it? <img src="modules/PNphpBB2/images/smiles/icon_lol.gif" alt="Laughing" border="0" /><hr />
<b>DocJC</b> - Sep 03, 2010 - 03:11 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<img src="modules/PNphpBB2/images/smiles/icon_lol.gif" alt="Laughing" border="0" /> 
<br />

<br />
JC<hr />
<b>katochd46</b> - Sep 03, 2010 - 04:14 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
ok got :--
<br />

<br />
I have to keep track of every position on LCD, page, x or y.
<br />
Then only i can make it to work
<br />

<br />
As said it is an sea of pixels.
<br />
so after every byte transfered to LCD i have to send the command to change the X position
<br />
so that lcd can put the next byte at that position.
<br />

<br />
please correct me if i am wrong.<hr />
<b>Lennart</b> - Sep 03, 2010 - 04:28 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">please correct me if i am wrong.</div>Yes, you are wrong.
<br />
X position is auto-incremented after each data write.
<br />
What you do need to keep track of is when you have reached end of left driver chip and end of right driver chip.<hr />
<b>katochd46</b> - Sep 03, 2010 - 04:55 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">What you do need to keep track of is when you have reached end of left driver chip and end of right driver chip.</div>thanks, and this will be useful to decide when we have to change the CS signal for diffrent chip.
<br />

<br />
Q.1
<br />
And also if i have reached 63 &amp; i have not changed the CS to right driver chip, Then if i again write byte will it be over written at 0 byte ?
<br />

<br />
Q.2
<br />
And when i have reached 63 --- then in this case i have to use diffrent CS signal i.e for right driver &amp; the numbering of byte will be keep track as 0 to 63 again for the right driver chip?
<br />

<br />
please correct me if i am wrong ?<hr />
<b>katochd46</b> - Sep 06, 2010 - 08:32 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I have completed the driver for G-Lcd .
<br />
But above two doubs are still not clarified ?
<br />

<br />
Can anyone answer ?<hr />
<b>david.prentice</b> - Sep 06, 2010 - 08:47 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Read your data sheet.
<br />

<br />
If you do not select the correct CS signal,   obviously you get the wrong 'half' of the display. 
<br />

<br />
Regarding 'wrap',   look at what bits you are sending to the KS0108 chip.
<br />
It will only do what the data sheet says.
<br />

<br />
Regarding 'doubt',  I presume you come from India.   All Indians seem to 'doubt' everything.
<br />
Non-Indians believe what data sheets say.   ( Sometimes at our peril !!! )
<br />

<br />
David.<hr />
<b>JohanEkdahl</b> - Sep 06, 2010 - 09:05 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Most &quot;doubts&quot; can be readily resolved with a few experiments, in the case that you do not trust the data sheet.
<br />

<br />
Re Q2, the two controllers are separate so AFAIK an address setting or increment in one controller will not in any way affect the other controller. (For a 128x64 display you need two controllers. A 64x64 could do with one controller, a 128x256 would need four controllers. And in that case you would have four CSn signals to the LCD module. The four controllers are not aware of each other.)<hr />
<b>katochd46</b> - Sep 06, 2010 - 09:16 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Regarding 'doubt', I presume you come from India. All Indians seem to 'doubt' everything. 
<br />
Non-Indians believe what data sheets say. </div>hmmm.. i think you have some problem with Indians....<img src="modules/PNphpBB2/images/smiles/icon_smile.gif" alt="Smile" border="0" />
<br />

<br />
Related to data sheet -- i have come to some conclusion &amp; started developing driver by reading data sheet first.
<br />

<br />
regarding datasheet of Ks0108B only thing mentioned is :--
<br />
<a href="http://www.techtoys.com.hk/Displays/JHD12864J/ks0108.pdf" target="_blank" class="postlink">http://www.techtoys.com.hk/Displays/JHD12864J/ks0108.pdf</a>Y address is set by instruction &amp; is incread by 1 automatically.
<br />
So i was bit confused that if if we have reached page boundary 63 &amp; then
<br />
keep on sending the byte without changing the chip select, does it overwraps
<br />
or keep on increasing. Under this senario there will be mismatch between
<br />
actual index &amp; the index maintained by code related to byte position.
<br />

<br />
Any how i will try to find some solution.<hr />
<b>JohanEkdahl</b> - Sep 06, 2010 - 09:21 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
So i was bit confused that if if we have reached page boundary 63 &amp; then
<br />
keep on sending the byte without changing the chip select, does it overwraps
<br />
or keep on increasing. Under this senario there will be mismatch between
<br />
actual index &amp; the index maintained by code related to byte position.
<br />

<br />
Any how i will try to find some solution.
<br />
</div>
<br />
Write one bit pattern up to the &quot;63-boundary&quot;, then change the bit pattern and write a few bits more. Do you see the new bit pattern occur at the start of the display? If &quot;yes&quot; then the wrap was done &quot;from 63 to zero&quot; , if &quot;no&quot; then it wasn't. The big question is, how will the outcome of this test affect your software? (I'd assume that you need to maintain an address in software regardless of the outcome, but that might just be me...<hr />
<b>katochd46</b> - Sep 06, 2010 - 09:25 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Write one bit pattern up to the &quot;63-boundary&quot;, then change the bit pattern and write a few bits more. Do you see the new bit pattern occur at the start of the display? If &quot;yes&quot; then the wrap was done &quot;from 63 to zero&quot; , if &quot;no&quot; then it wasn't. The big question is, how will the outcome of this test affect your software? (I'd assume that you need to maintain an address in software regardless of the outcome, but that might just be me...</div>
<br />
thanks johan,
<br />
i will experiment then only i can come to final conclusion<hr />
<b>david.prentice</b> - Sep 06, 2010 - 09:48 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">hmmm.. i think you have some problem with Indians....</div>
<br />

<br />
No.  I have no problems with Indians.    I do 'notice' the unusual use of 
<br />
English words.    Most Indians have an excellent command of the English 
<br />
language.   So it stands out when there is an unusual expression.
<br />

<br />
I cannot speak any other languages !
<br />
I admire those that can.
<br />
I do 'notice' the fundamental differences in culture. e.g. I trust.   You doubt.
<br />

<br />
The World is a better place for all our differences.
<br />

<br />
Regarding your original question: page 13 of the data sheet shows the Y register 
<br />
goes from 0..63.   i.e. only 6 bits.
<br />
Yes.  I would also wonder what happens.   So I would just try it and see for 
<br />
myself.    Even if my 'experiments' reveal that only 6 bits are used,   it is 
<br />
still wise to program defensively.   So if Samsung came out with a KS0108 
<br />
revision #1234 that somehow uses 7 bits,  my code would still work ok.
<br />

<br />
David.<hr />
<b>bperrybap</b> - Sep 06, 2010 - 10:07 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
What I have seen looking at many different vendors ks0108 modules and writing library code that works on them, is that documentation with respect to how wraps work is seldom available and often unclear or ambiguous.
<br />
In real world tests, I have seen that different modules handle it differently.
<br />

<br />
Note: I'm using the term &quot;module column&quot; to refer
<br />
to what is normally an X coordinate (i.e 0-127).
<br />
I'm trying not to use X coordinate as the ks0108 documentation uses X to refer to vertical page address rather than horizontal column addresses.
<br />

<br />
The chip column address does increment on every write or read, but what happens after a write/read to the right most column of a chip varies between different ks0108 modules.
<br />
Some chips wrap back to 0 and some stay at the highest address for that chip.
<br />

<br />

<br />
As Johan pointed out, each chip on a ks0108 module is separate and tracks its own column address.
<br />
Each chip handles up to 64 pages/columns and handles its own wrapping independently of the other chips on the module.
<br />
(some modules are not multiples of 64 wide so the right most chip is less than 64 pages).
<br />
So on a 2 chip module that is 128 pixels across, each chip goes from 0-63 and column 64 for the module is column 0 for the right most chip.
<br />
When you write to module column 63, which is chip 0 column 63, some modules will set chip 0 column back 0 and some leave it a 63.
<br />
Same is true for &quot;module column&quot; 127 which is chip 1 column 63. Some chips will wrap chip 1 address back 0 and some will leave chip 1 address at 63.
<br />

<br />
For modules that are not a multiple of 64, the right most chip will walk off the end of its display memory.
<br />

<br />
So the only way to write code that works on different modules and especially on modules that are not multiples of 64 pixels wide,
<br />
is to not make any assumptions about how wrapping works
<br />
and simply handle a wrap back &quot;module column&quot; 0 yourself.
<br />

<br />
But in real life, a wrap back to &quot;module column&quot; 0 seldom happens unless there is some sort of frame buffer or bitmap dump going on.
<br />

<br />
For block type operations like that,
<br />
the safest thing to do is to write the pages column by column for each row, making sure to handle the chip crossings and then wrap back to &quot;module column&quot; 0 when changing rows.
<br />

<br />
I don't use a frame buffer in my code but I do
<br />
track the column for each chip separately and only send a set column command to a chip when the desired column for that chip does not match the hardware column in the desired chip. (the s/w keeps track of the hardware column)
<br />
&quot;Module columns&quot; get mapped to chip #s and chip columns and then set column commands for a chip get sent when necessary. By doing it this way, wraps and chip crossings get handled &quot;for free&quot; as the logic automagically detects the column mismatches at the appropriate boundary locations (chip crossings and wraps) including on modules
<br />
that are not multiples of 64 in width.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 09, 2010 - 01:51 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
double post by mistake<hr />
<b>katochd46</b> - Sep 09, 2010 - 01:51 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Pin numbering for jhd LCD :---
<br />

<br />
I was able to get the datasheet for ks0108b but
<br />
Did not find datasheet for JHD 128x64 lcd
<br />

<br />
just to confirm,
<br />

<br />
Is this the front view of the LCD, means numbering starts from right to left.
<br />

<br />
20,19, ..... 1
<br />

<br />
This link gives the info, but i just want to confirm that it is front view of LCD ?
<br />

<br />
<a href="http://www.ioffer.com/i/Graphic-Matrix-LCD-Module-LCM-JHD-12864-E-128X64-118744645" target="_blank" class="postlink">http://www.ioffer.com/i/Graphic-Matrix-LCD-Module-LCM-JHD-12864-E-128X64-118744645</a><hr />
<b>JohanEkdahl</b> - Sep 09, 2010 - 02:02 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Is this the front view of the LCD, means numbering starts from right to left.
<br />
</div>
<br />
Yes, by the looks of it the pins are numbered from right to left in front view and connector at lower end.
<br />

<br />
Take a look at the actual module. I would not be surprised if you find a small &quot;1&quot; on the PCD at one end of the connector and a small &quot;20&quot; at the other in end. More or less like in the picture you posted above.<hr />
<b>bobgardner</b> - Sep 09, 2010 - 02:09 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
So the slow precise way to set a pixel is: calc byte address and bitmask for the bit you want to set, fetch the byte, set the bit, write the byte back. Now to set the next pixel, chances are 1 in 8 the byte will be the same, so if you keep the 'last address fetched' and 'last byte written' hanging around in one of those horrid global locations, you can skip the load 7 times out of 8. I still like my way of drawing into a ram buffer, then copying 1k bytes a byte at a time.<hr />
<b>JohanEkdahl</b> - Sep 09, 2010 - 02:40 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">so if you keep the 'last address fetched' and 'last byte written' hanging around in one of those horrid global locations</div>
<br />
Bob! A GLCD driver with a (smaller or larger amount of caching/buffering) would lend itself excellently to OO programming. The horrid globals (the chache, or state if you like) becomes first class private members of the GLCD class. <img src="modules/PNphpBB2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0" /><hr />
<b>katochd46</b> - Sep 09, 2010 - 03:44 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent"> I would not be surprised if you find a small &quot;1&quot; on the PCD at one end of the connector and a small &quot;20&quot; at the other in end. </div>
<br />

<br />
Yes numbering is done on the back side of LCD -- starts from right to left.<hr />
<b>bobgardner</b> - Sep 09, 2010 - 04:24 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
The global and the private vars are both allocated in bss, so neither is faster than the other, its also not any more immune to a runaway fill. Only advantage I can see of a private var is it might keep an unorganized programmer from using the wrong var by accident.<hr />
<b>JohanEkdahl</b> - Sep 09, 2010 - 09:00 PM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
It was you who chose the wording &quot;horrid globals&quot;... <img src="modules/PNphpBB2/images/smiles/icon_biggrin.gif" alt="Very Happy" border="0" />
<br />

<br />
My comment was only half tounge-in-cheek. This is a prime example of where encapsulation, and hiding of implementation and &quot;inner state&quot;, comes natural. I agree fully with your statement that efficiency-of-execution-wise there is no difference between your global variables and OO objects.
<br />

<br />
Most programmers I've met are un-organized..<hr />
<b>katochd46</b> - Sep 10, 2010 - 08:35 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I still like my way of drawing into a ram buffer, then copying 1k bytes a byte at a time.</div>
<br />
But keeping 1Kbyte buffer reserved is it an efficent embeded programming.<hr />
<b>katochd46</b> - Sep 10, 2010 - 10:13 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
can i connect ;--
<br />

<br />
Pin 18(Vee) --- to ground
<br />
Pin 3(contast adjust) --- to VCC directly
<br />

<br />
I do not need contast adjust.<hr />
<b>clawson</b> - Sep 10, 2010 - 10:48 AM<br />
<b>Post subject: </b>RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Pin 18(Vee) --- to ground 
<br />
Pin 3(contast adjust) --- to VCC directly 
<br />

<br />
I do not need contast adjust.
<br />
</div>
<br />
Not normally possible. On character displays the contrast voltage needs to be set at about 0.1V to 0.3V when Vcc is 5V. For graphic LCD the voltage sometimes actually needs to be negative. The one voltage that's almost guaranteed not to work is Vcc. For your prototype you need to wire up a pot so you can adjust it until it &quot;looks right&quot;. For later production you may just be able to wire up a permanent potential divider.
<br />

<br />
Another option that I've found to work very well (with character displays) when I simply didn't have a suitable pot to hand was to wire the contrast pin to a PWM output pin from the AVR then just vary the duty cycle to adjust the contrast. This then gives you &quot;soft&quot; control over the contrast so that if the unit has buttons and is driven by a menu system the user can select a &quot;set contrast&quot; function where up/down button vary the PWM duty and when settled the user's selection is committed to EEPROM.<hr />
<b>bperrybap</b> - Sep 10, 2010 - 11:24 AM<br />
<b>Post subject: </b>Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle">bobgardner wrote:</div><div class="quotecontent">So the slow precise way to set a pixel is: calc byte address and bitmask for the bit you want to set, fetch the byte, set the bit, write the byte back. Now to set the next pixel, chances are 1 in 8 the byte will be the same, so if you keep the 'last address fetched' and 'last byte written' hanging around in one of those horrid global locations, you can skip the load 7 times out of 8. I still like my way of drawing into a ram buffer, then copying 1k bytes a byte at a time.</div>
<br />

<br />

<br />
In terms of talking to the GLCD it will be:
<br />
- set page (if necessary)
<br />
- set column (if necessary)
<br />
- dummy read
<br />
- real read to variable
<br />
- set column (back to column before read advanced it)
<br />
- or in pixel bit to variable
<br />
- Write variable to glcd
<br />

<br />
The extra 7 loads only occurs if you happen to be painting
<br />
a vertical line starting on a page boundary.<hr />
<b>bperrybap</b> - Sep 10, 2010 - 11:29 AM<br />
<b>Post subject: </b>Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle">JohanEkdahl wrote:</div><div class="quotecontent"> I agree fully with your statement that efficiency-of-execution-wise there is no difference between your global variables and OO objects.
<br />
</div>
<br />

<br />
A little off topic, but not what I've seen.
<br />
(depending on how you use &amp; reference the objects)
<br />
C++ generates extra call overhead by pushing the &quot;this&quot; pointer around. Also globals, especially when structures
<br />
are used generate much more efficient code when dealing with structure members than pointers to structure elements.
<br />
i.e. Var.member when Var is global generates much better
<br />
code than Var-&gt;member which is what happens when referencing off the &quot;this&quot; pointer.
<br />

<br />
But sometimes the extra overhead is worth it, and depending on what is being done, pointers may be necessary anyway to support multiple instances.
<br />

<br />
--- bill<hr />
<b>JohanEkdahl</b> - Sep 10, 2010 - 12:20 PM<br />
<b>Post subject: </b>RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
C++ generates extra call overhead by pushing the &quot;this&quot; pointer around.
<br />
</div>
<br />
As long as there is only one instance of the physical display to handle, members of the driver class can be static. No this-pointer, but you still get encapsulation.
<br />

<br />
If you want to drive several displays with one driver you make the members non-static. For the same thing in C you will probably pass a pointer to a struct with the state of the driver for a certain display.
<br />

<br />
In C++ state data is passed implicitly. In C you must explicitly pass state data.
<br />

<br />
Or, looking at the same situation from the other side: If you do not need to pass state data in your C implementation, then the corresponding C++ member function can be static (again, no this-pointer). Similar for variable: If you where content with a statically allocated global variable in C then a static member variable in C++ will do.<hr />
<b>katochd46</b> - Sep 10, 2010 - 01:47 PM<br />
<b>Post subject: </b>RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I am able to display some caracter on LCD.
<br />

<br />
But i dont know why my LCD is fluctuating on to off ?<hr />
<b>katochd46</b> - Sep 10, 2010 - 02:44 PM<br />
<b>Post subject: </b>RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Initially i did this type of connection before --- can it be the case my LCD is gone. It is fluctuating on to off.
<br />

<br />
I am using meha16l and 8mhz external crystal.
<br />

<br />
Pin 18(Vee) --- to ground 
<br />
Pin 3(contast adjust) --- to VCC directly<hr />
<b>katochd46</b> - Sep 10, 2010 - 03:13 PM<br />
<b>Post subject: </b>RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
will someone like look at lcd driver, data is not displayed as expected. where the logic is getting wrong ?
<br />

<br />
main :---
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">int main&#40;void&#41; &#123;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// Wait a little while the display starts up
<br />
&nbsp; &nbsp;for&#40;volatile uint16_t i=0; i&lt;15000; i++&#41;;
<br />
&nbsp; &nbsp;// Initialize the LCD
<br />
&nbsp; &nbsp;ks0108Init&#40;0&#41;;
<br />
&nbsp; &nbsp;ks0108GotoXY&#40;0,0&#41;;
<br />

<br />

<br />
&nbsp; &nbsp;// Print some text
<br />
&nbsp; &nbsp;ks0108Puts_P&#40;PSTR&#40;&quot;AAAAAAAAAAA&quot;&#41;&#41;;
<br />
&nbsp; &nbsp;while&#40;1&#41;;
<br />
&#125;</div>
<br />

<br />
Header file :---
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">#define DISPLAY_STATUS_BUSY&nbsp; &nbsp;0x80
<br />

<br />
// Ports
<br />
#define LCD_CMD_PORT&nbsp; &nbsp;&nbsp; &nbsp;PORTD&nbsp; &nbsp;&nbsp; &nbsp;// Command Output Register
<br />
#define LCD_CMD_DIR&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DDRD&nbsp; &nbsp;&nbsp; &nbsp;// Data Direction Register for Command Port
<br />

<br />
#define LCD_DATA_IN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;PINA&nbsp; &nbsp;&nbsp; &nbsp;// Data Input Register
<br />
#define LCD_DATA_OUT&nbsp; &nbsp;&nbsp; &nbsp;PORTA&nbsp; &nbsp;&nbsp; &nbsp;// Data Output Register
<br />
#define LCD_DATA_DIR&nbsp; &nbsp;&nbsp; &nbsp;DDRA&nbsp; &nbsp;&nbsp; &nbsp;// Data Direction Register for Data Port
<br />

<br />
// Command Port Bits
<br />
#define D_I&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x03&nbsp; &nbsp;&nbsp; &nbsp;// D/I Bit Number
<br />
#define R_W&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x04&nbsp; &nbsp;&nbsp; &nbsp;// R/W Bit Number
<br />
#define EN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x05&nbsp; &nbsp;&nbsp; &nbsp;// EN Bit Number
<br />
#define CSEL1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x06&nbsp; &nbsp;&nbsp; &nbsp;// CS1 Bit Number
<br />
#define CSEL2&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x07&nbsp; &nbsp;&nbsp; &nbsp;// CS2 Bit Number
<br />

<br />
// Chips
<br />
#define CHIP1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x00
<br />
#define CHIP2&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x01
<br />

<br />
// Commands
<br />
#define LCD_ON&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3F
<br />
#define LCD_OFF&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3E
<br />
#define LCD_SET_ADD&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x40
<br />
#define LCD_SET_PAGE&nbsp; &nbsp;&nbsp; &nbsp;0xB8
<br />
#define LCD_DISP_START&nbsp; &nbsp;&nbsp; &nbsp;0xC0
<br />

<br />
// Colors
<br />
#define BLACK&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0xFF
<br />
#define WHITE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x00
<br />

<br />
#define KS0108_SCREEN_WIDTH&nbsp; &nbsp;&nbsp; &nbsp;128
<br />
#define KS0108_SCREEN_HEIGHT&nbsp; &nbsp;64</div>
<br />

<br />
LCD function file ::---
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">//-------------------------------------------------------------------------------------------------
<br />
//
<br />
//-------------------------------------------------------------------------------------------------
<br />
void GLCD_WriteChar&#40;char charToWrite&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;int i;
<br />
&nbsp; &nbsp;uint8_t chip, cmd;
<br />

<br />
&nbsp; &nbsp;charToWrite -= 32;&nbsp; // -32 as we are only storing character set with decimal value &gt;= 32 i.e from space
<br />
&nbsp; &nbsp;// As each character is of font 5x8 i.e 5 column &amp; 8 rows
<br />
&nbsp; &nbsp;for&#40;i = 0; i &lt; 5; i++&#41; 
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;// make pixel to point towards right position
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ks0108Coord.x += i;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;// select the right chip
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;ks0108Coord.x == 0&#41;||&#40;ks0108Coord.x == 64&#41;&#41; 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;ks0108Coord.x == 64&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP2;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else&nbsp; // i.e i == 0
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cmd = LCD_SET_ADD | 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, chip&#41;;&nbsp; &nbsp;&nbsp; &nbsp;// set x address on active chip as -- 0
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;GLCD_WriteData&#40;pgm_read_byte&#40;&#40;char *&#41;&#40;&#40;int&#41;font5x8 + &#40;5 * charToWrite&#41; + i&#41;&#41;&#41;; 
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;/* 
<br />
&nbsp; &nbsp; &nbsp; &nbsp;after displaying one character increase the 
<br />
&nbsp; &nbsp; &nbsp; &nbsp;x cordinate i.e the length by 1 as font is 5 pixel wide
<br />
&nbsp; &nbsp; &nbsp; &nbsp;already increased in above for loop
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &amp; 1 pixel left between the lines
<br />
&nbsp; &nbsp;*/
<br />
&nbsp; &nbsp;// write 0x00 to give one pixel gap &amp; make x-cordinate to point to actual position
<br />
&nbsp; &nbsp;// so that to keep track from the software point of view&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// make pixel to point towards right position
<br />
&nbsp; &nbsp;ks0108Coord.x += 1;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// select the right chip
<br />
&nbsp; &nbsp;if&#40;&#40;ks0108Coord.x == 0&#41;||&#40;ks0108Coord.x == 64&#41;&#41; 
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;ks0108Coord.x == 64&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP2;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;else&nbsp; // i.e i == 0
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;cmd = LCD_SET_ADD | 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, chip&#41;;&nbsp; &nbsp;&nbsp; &nbsp;// set x address on active chip as -- 0
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;GLCD_WriteData&#40;0x00&#41;;
<br />

<br />
&nbsp; &nbsp;/* After writting 0x00 as we know that lcd cursor pointer will auto increment to point
<br />
&nbsp; &nbsp;&nbsp; &nbsp;to next vertical row of 8 bits*/
<br />
&nbsp; &nbsp;// change the pixel position to point to position after one vertical row of 8 bits gap
<br />
&nbsp; &nbsp;ks0108Coord.x += 1;
<br />
&nbsp; &nbsp;/* no need to select the right chip because when the next time
<br />
&nbsp; &nbsp;&nbsp; &nbsp;we will enter GLCD_WriteChar function this condition will be checked first
<br />
&nbsp; &nbsp;*/&nbsp; &nbsp;
<br />

<br />
&#125;
<br />

<br />
//-------------------------------------------------------------------------------------------------
<br />
//
<br />
//-------------------------------------------------------------------------------------------------
<br />
void ks0108Puts&#40;char* str&#41; &#123;
<br />
//&nbsp; &nbsp;int x = ks0108Coord.x;
<br />
&nbsp; &nbsp;while&#40;*str != 0&#41; 
<br />
&nbsp; &nbsp;&#123;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;GLCD_WriteChar&#40;*str&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;str++;
<br />
&nbsp; &nbsp;&#125;
<br />
&#125;
<br />

<br />
//-------------------------------------------------------------------------------------------------
<br />
//
<br />
//-------------------------------------------------------------------------------------------------
<br />
void ks0108Puts_P&#40;PGM_P str&#41; 
<br />
&#123;
<br />
&nbsp; &nbsp;//int x = ks0108Coord.x;
<br />
&nbsp; &nbsp;while&#40;pgm_read_byte&#40;str&#41; != 0&#41; 
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;GLCD_WriteChar&#40;pgm_read_byte&#40;str&#41;&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;str++;
<br />
&nbsp; &nbsp;&#125;
<br />
&#125;
<br />

<br />
//-------------------------------------------------------------------------------------------------
<br />
// Delay function
<br />
//-------------------------------------------------------------------------------------------------
<br />
void GLCD_Delay&#40;void&#41;
<br />
&#123;
<br />
asm&#40;&quot;nop&quot;&#41;;
<br />
&#125;
<br />

<br />
//-------------------------------------------------------------------------------------------------
<br />
// Read Status from specified controller &#40;0-1&#41; -- hardware dependent function
<br />
//-------------------------------------------------------------------------------------------------
<br />
unsigned char GLCD_ReadStatus&#40;unsigned char controller&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;unsigned char status;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;LCD_DATA_DIR = 0x00;&nbsp; // set all pins as INPUT
<br />
&nbsp; &nbsp;LCD_CMD_DIR = 0xFF;&nbsp; &nbsp;&nbsp; // command port is output
<br />

<br />
&nbsp; &nbsp;LCD_CMD_PORT |= &#40;0x01 &lt;&lt;R_W&#41;;&nbsp; // read - high , write - low
<br />
&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;D_I&#41;; // data - high , instruction - low
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// chip select for respective controller
<br />
&nbsp; &nbsp;// GLCD_EnableController&#40;controller&#41;;
<br />
&nbsp; &nbsp;switch&#40;controller&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;case 0 &#58; LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;CSEL1&#41;; break;
<br />
&nbsp; &nbsp;case 1 &#58; LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;CSEL2&#41;; break;
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// read status
<br />
&nbsp; &nbsp;// send high to low on the enable line
<br />
&nbsp; &nbsp;LCD_CMD_PORT |= &#40;0x01 &lt;&lt;EN&#41;;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;GLCD_Delay&#40;&#41;;
<br />
&nbsp; &nbsp;status = LCD_DATA_IN;&nbsp; &nbsp;// read status
<br />
&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;EN&#41;;
<br />

<br />
&nbsp; &nbsp;// chip de-select for respective controller
<br />
&nbsp; &nbsp;// GLCD_DisableController&#40;controller&#41;;
<br />
&nbsp; &nbsp;switch&#40;controller&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;case 0 &#58; LCD_CMD_PORT |= &#40;0x01 &lt;&lt;CSEL1&#41;; break;
<br />
&nbsp; &nbsp;case 1 &#58; LCD_CMD_PORT |= &#40;0x01 &lt;&lt;CSEL2&#41;; break;
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;return status;
<br />
&#125;
<br />
//-------------------------------------------------------------------------------------------------
<br />
// Write data to current position -- hardware dependent function
<br />
//-------------------------------------------------------------------------------------------------
<br />
void GLCD_WriteData&#40;unsigned char dataToWrite&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;uint8_t controller_local;
<br />

<br />
&nbsp; &nbsp;controller_local = ks0108Coord.x / 64;
<br />
&nbsp; &nbsp;//#define DISPLAY_STATUS_BUSY&nbsp; &nbsp;0x80
<br />
&nbsp; &nbsp;// check the status of the respective controller
<br />
&nbsp; &nbsp;while&#40;GLCD_ReadStatus&#40;controller_local&#41;&amp;DISPLAY_STATUS_BUSY&#41;;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// write data to the LCD
<br />
&nbsp; &nbsp;LCD_DATA_DIR = 0xFF;&nbsp; &nbsp; // set all pins as OUTPUT
<br />
&nbsp; &nbsp;LCD_CMD_DIR = 0xFF;&nbsp; &nbsp;&nbsp; // command port is output
<br />
&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;R_W&#41;; // read - high , write - low
<br />
&nbsp; &nbsp;LCD_CMD_PORT |= &#40;0x01 &lt;&lt;D_I&#41;;&nbsp; // data - high , instruction - low
<br />
&nbsp; &nbsp;LCD_DATA_OUT = dataToWrite;
<br />

<br />
&nbsp; &nbsp;// chip select for respective controller
<br />
&nbsp; &nbsp;//GLCD_EnableController&#40;ks0108Coord.x / 64&#41;;
<br />
&nbsp; &nbsp;// GLCD_EnableController&#40;controller&#41;;
<br />
&nbsp; &nbsp;switch&#40;controller_local&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;case 0 &#58; LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;CSEL1&#41;; break;
<br />
&nbsp; &nbsp;case 1 &#58; LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt;CSEL2&#41;; break;
<br />
&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;// send high to low on the enable line
<br />
&nbsp; &nbsp;ks0108Enable&#40;&#41;;
<br />

<br />
&nbsp; &nbsp;// chip de-select for respective controller
<br />
&nbsp; &nbsp;//GLCD_DisableController&#40;ks0108Coord.x / 64&#41;;
<br />
&nbsp; &nbsp;switch&#40;controller_local&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;case 0 &#58; LCD_CMD_PORT |= &#40;0x01 &lt;&lt;CSEL1&#41;; break;
<br />
&nbsp; &nbsp;case 1 &#58; LCD_CMD_PORT |= &#40;0x01 &lt;&lt;CSEL2&#41;; break;
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;//screen_x++;
<br />
&#125;
<br />
/* -----------------------------------------------------------------------------------
<br />
// Function to clear the LCD
<br />
&nbsp;-----------------------------------------------------------------------------------*/
<br />
void ks0108ClearScreen&#40;void&#41;&nbsp; // i.e all screen white with no black dot --- i.e WHITE 0x00
<br />
&#123;
<br />
&nbsp; &nbsp;unsigned char i, j;
<br />
&nbsp; &nbsp;uint8_t chip = CHIP1, cmd, x = 0;
<br />

<br />
&nbsp; &nbsp;/*make display line to point to the begning for clearing purpose*/
<br />
&nbsp; &nbsp;// LCD_DISP_START&nbsp; &nbsp;&nbsp; &nbsp;0xC0&nbsp; &nbsp;display start line = 0 
<br />
&nbsp; &nbsp;// i.e 128x64 lcd so in this out of 64 which line to go for starting position - 0 th line
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP2&#41;;
<br />

<br />
&nbsp; &nbsp;for&#40;j = 0; j &lt; KS0108_SCREEN_HEIGHT/8; j++&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;/*
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;set x=0 &amp; y as the starting line of the page
<br />
&nbsp; &nbsp;&nbsp; &nbsp;*/
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ks0108GotoXY&#40;0,j*8&#41;; 
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;for&#40;i = 0; i &lt; KS0108_SCREEN_WIDTH; i++&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// select the right chip
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;i == 0&#41;||&#40;i == 64&#41;&#41; 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;i == 64&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP2;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else&nbsp; // i.e i == 0
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cmd = LCD_SET_ADD | x;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, chip&#41;;&nbsp; &nbsp;&nbsp; &nbsp;// set x address on active chip as -- 0
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;GLCD_WriteData&#40;WHITE&#41;;&nbsp; // WHITE 0x00
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* Once LCD is clear again make display line to point to the begining*/
<br />
&nbsp; &nbsp;// LCD_DISP_START&nbsp; &nbsp;&nbsp; &nbsp;0xC0&nbsp; &nbsp;display start line = 0 
<br />
&nbsp; &nbsp;// i.e 128x64 lcd so in this out of 64 which line to go for 0th line - starting position
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP2&#41;;
<br />

<br />
&nbsp; &nbsp;// save new coordinates
<br />
&nbsp; &nbsp;ks0108Coord.x = 0;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108Coord.y = 0;
<br />
&#125;
<br />

<br />
/* -----------------------------------------------------------------------------------
<br />
// here only x &amp; page command is send
<br />
//&nbsp; &nbsp;---- save new coordinates ----
<br />
//&nbsp; &nbsp;ks0108Coord.x = x;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
//&nbsp; &nbsp;ks0108Coord.y = y;
<br />
//&nbsp; &nbsp;ks0108Coord.page = y/8;
<br />
-----------------------------------------------------------------------------------*/
<br />
void ks0108GotoXY&#40;uint8_t x, uint8_t y&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;uint8_t chip = CHIP1, cmd;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;if&#40;x &gt; 127&#41; x = 0;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// ensure that coordinates are legal
<br />
&nbsp; &nbsp;if&#40;y &gt; 63&#41;&nbsp; y = 0;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108Coord.x = x;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// save new coordinates
<br />
&nbsp; &nbsp;ks0108Coord.y = y;
<br />
&nbsp; &nbsp;ks0108Coord.page = y/8;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;if&#40;x &gt;= 64&#41; &#123;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// select the right chip
<br />
&nbsp; &nbsp;&nbsp; &nbsp;x -= 64;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;chip = CHIP2;
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;cmd = LCD_SET_ADD | x;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, chip&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// set x address on active chip
<br />

<br />
&nbsp; &nbsp;// set page address for requested cordinate
<br />
&nbsp; &nbsp;cmd = LCD_SET_PAGE | ks0108Coord.page;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// set y address on both chips
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, CHIP1&#41;;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, CHIP2&#41;;
<br />
&#125;
<br />

<br />
void ks0108Init&#40;uint8_t invert&#41; &#123;
<br />
&nbsp; &nbsp;ks0108Coord.x = 0;
<br />
&nbsp; &nbsp;ks0108Coord.y = 0;
<br />
&nbsp; &nbsp;ks0108Coord.page = 0;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;//ks0108Inverted = invert;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;LCD_CMD_DIR = 0xFF;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// command port is output
<br />
&nbsp; &nbsp;// #define LCD_ON&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3F
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_ON, CHIP1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// power on
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_ON, CHIP2&#41;;
<br />

<br />
&nbsp; &nbsp;// LCD_DISP_START&nbsp; &nbsp;&nbsp; &nbsp;0xC0&nbsp; &nbsp;display start line = 0 
<br />
&nbsp; &nbsp;// i.e 128x64 lcd so in this out of 64 which line to go for starting position
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP2&#41;;
<br />

<br />
&nbsp; &nbsp;ks0108ClearScreen&#40;&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// display clear
<br />
&nbsp; &nbsp;ks0108GotoXY&#40;0,0&#41;;
<br />
&#125;
<br />

<br />
inline void ks0108Enable&#40;void&#41; 
<br />
&#123;
<br />
&nbsp; &nbsp;LCD_CMD_PORT |= 0x01 &lt;&lt; EN;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// EN high level width&#58; min. 450ns
<br />
&nbsp; &nbsp;asm volatile&#40;&quot;nop\n\t&quot;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &quot;nop\n\t&quot;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &quot;nop\n\t&quot;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &#58;&#58;&#41;;
<br />
&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt; EN&#41;;
<br />
&nbsp; &nbsp;for&#40;volatile uint8_t i=0; i&lt;8; i++&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// a little delay loop &#40;faster than reading the busy flag&#41;
<br />
&#125;
<br />

<br />
void ks0108WriteCommand&#40;uint8_t cmd, uint8_t chip&#41; &#123;
<br />
&nbsp; &nbsp;if&#40;chip == CHIP1&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt; CSEL2&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// deselect chip 2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;LCD_CMD_PORT |= 0x01 &lt;&lt; CSEL1;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// select chip 1
<br />
&nbsp; &nbsp;&#125; else if&#40;chip == CHIP2&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt; CSEL1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// deselect chip 1
<br />
&nbsp; &nbsp;&nbsp; &nbsp;LCD_CMD_PORT |= 0x01 &lt;&lt; CSEL2;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// select chip 2
<br />
&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt; D_I&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// D/I = 0
<br />
&nbsp; &nbsp;LCD_CMD_PORT &amp;= ~&#40;0x01 &lt;&lt; R_W&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// R/W = 0
<br />
&nbsp; &nbsp;LCD_DATA_DIR = 0xFF;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// data port is output
<br />
&nbsp; &nbsp;LCD_DATA_OUT = cmd;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// write command
<br />
&nbsp; &nbsp;ks0108Enable&#40;&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// enable
<br />
&nbsp; &nbsp;LCD_DATA_OUT = 0x00;
<br />
&#125;</div><hr />
<b>bperrybap</b> - Sep 10, 2010 - 08:57 PM<br />
<b>Post subject: </b>Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle">katochd46 wrote:</div><div class="quotecontent">Initially i did this type of connection before --- can it be the case my LCD is gone. It is fluctuating on to off.
<br />

<br />
I am using meha16l and 8mhz external crystal.
<br />

<br />
Pin 18(Vee) --- to ground 
<br />
Pin 3(contast adjust) --- to VCC directly</div>
<br />

<br />
Stop!
<br />
Time to take a closer look at a ks0108 datasheet before any further testing.
<br />
Vee is normally an output not an input.
<br />

<br />
Hooking Vee to ground is shorting out the onboard negative voltage powersupply.
<br />

<br />
Hook up a 10k or larger potentiometer between
<br />
VCC and Vee with the wiper of the pot hooked up to Vo.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 11, 2010 - 08:35 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I simply want to display two characters &quot;AB&quot; on LCD.
<br />

<br />
I am cosidering that Chip select signal is active high signal for both the chips of LCD.
<br />

<br />
I want to be sure that is it correct sequence to intialise LCD?
<br />

<br />
for both chip i am sending following command:---
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">power off
<br />
power on
<br />
set page-- address on both chips as 0
<br />
LCD display start command (i.e selecting row) -- on both chips as 0
<br />
set x address (i.e selecting column) -- on both chips as 0</div>
<br />

<br />

<br />

<br />
Please suggest is it the right way to initialise LCD.
<br />

<br />
#defines :--
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">// Commands
<br />
#define LCD_ON&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3F
<br />
#define LCD_OFF&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3E
<br />
#define LCD_SET_ADD&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x40
<br />
#define LCD_SET_PAGE&nbsp; &nbsp;&nbsp; &nbsp;0xB8
<br />
#define LCD_DISP_START&nbsp; &nbsp;&nbsp; &nbsp;0xC0
<br />

<br />
// Ports
<br />
#define LCD_CMD_PORT&nbsp; &nbsp;&nbsp; &nbsp;PORTD&nbsp; &nbsp;&nbsp; &nbsp;// Command Output Register
<br />
#define LCD_CMD_DIR&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DDRD&nbsp; &nbsp;&nbsp; &nbsp;// Data Direction Register for Command Port
<br />

<br />
#define LCD_DATA_IN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;PINA&nbsp; &nbsp;&nbsp; &nbsp;// Data Input Register
<br />
#define LCD_DATA_OUT&nbsp; &nbsp;&nbsp; &nbsp;PORTA&nbsp; &nbsp;&nbsp; &nbsp;// Data Output Register
<br />
#define LCD_DATA_DIR&nbsp; &nbsp;&nbsp; &nbsp;DDRA&nbsp; &nbsp;&nbsp; &nbsp;// Data Direction Register for Data Port</div>
<br />

<br />
Initialisation function ;--
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp;// set data-diection on PORT -- output
<br />
&nbsp; &nbsp;LCD_CMD_DIR = 0xFF;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// command port is output
<br />
&nbsp; &nbsp;LCD_DATA_DIR = 0xFF;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// data port is output
<br />

<br />
&nbsp; &nbsp;// power off
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_OFF, CHIP1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_OFF, CHIP2&#41;;
<br />

<br />
&nbsp; &nbsp;// give delay between off &amp; on
<br />
&nbsp; &nbsp;ks0108_Delay&#40;&#41;;&nbsp; &nbsp;
<br />

<br />
&nbsp; &nbsp;// power on
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_ON, CHIP1&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_ON, CHIP2&#41;;
<br />

<br />
&nbsp; &nbsp;// set --page-- address on both chips
<br />
&nbsp; &nbsp;cmd = LCD_SET_PAGE | ks0108Coord.page;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, CHIP2&#41;;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, CHIP1&#41;;
<br />

<br />
&nbsp; &nbsp;// i.e 128x64 lcd so in this out of 64 which line to go for starting position
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP2&#41;;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 0, CHIP1&#41;;
<br />

<br />
&nbsp; &nbsp;// set x address on both chip as -- 0
<br />
&nbsp; &nbsp;cmd = LCD_SET_ADD | 0;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, CHIP2&#41;;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;cmd, CHIP1&#41;;&nbsp; &nbsp;</div><hr />
<b>katochd46</b> - Sep 11, 2010 - 04:45 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I am ablt make the display work. It is writing at correct location, if i choose display start line as 0.
<br />

<br />
But i am bit confused with the command :--
<br />
LCD_DISP_START --- 0xC0 --- 11xxxxxx
<br />

<br />
when i gave this command as display start line as 4, page-0 &amp; column 0 and displayed the text &quot; KS108B-JHD12864E &quot;
<br />

<br />
Its half top part is comming at the bottom of the screen, while the bottom half part is comming at the top of the screen
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp;&nbsp; &nbsp;// i.e 128x64 lcd so in this out of 64 which line to go for starting position
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 4, CHIP2&#41;;
<br />
&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | 4, CHIP1&#41;;
<br />

<br />
&nbsp; &nbsp;// Print some text to Zero page
<br />
&nbsp; &nbsp; ks0108Puts_P&#40;PSTR&#40;&quot; KS108B-JHD12864E &quot;&#41;&#41;;</div>
<br />

<br />

<br />
Can anyone suggest what is the exact role of this command ?
<br />

<br />
At present i am able to display the character in the one page, but if i want that my string comes in two page boundary, eg half body in page 0 &amp; other half of body of character in page 1 than what do i have to do ?<hr />
<b>clawson</b> - Sep 11, 2010 - 06:45 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Can anyone suggest what is the exact role of this command ? 
<br />
</div>
<br />
Scrolling. By adjusting here it starts the frame scan in the buffer the entire display can be scrolled (try a for() loop incrementing the display start). As some bits &quot;fall off&quot; the screen you need to re-write those with the &quot;newline&quot; that appears - but it lets you scroll the display without having to rewrite the entire frame buffer. Often the increment in the start will be a whole character or a whole line.<hr />
<b>katochd46</b> - Sep 12, 2010 - 05:17 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I am new to graphics thanks for some reply.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Often the increment in the start will be a whole character or a whole line.</div>
<br />
I tried this approch &amp; increased the display start Address by 8 line. 
<br />
Means that if i set LCD_DISP_START = 0 &amp; page 0 write &quot;hello&quot; on page 0. Give some 10000 ms delay &amp; then again set LCD_DISP_START 8 &amp; page 1, &amp; write &quot;how are you&quot;. then How are you moves to the top of the screen &amp; &quot;Hello&quot; scroll down to bottom.
<br />
Conclusion is that it will display &quot;how are you&quot; on page 1 &amp; set display start Address to 8th line then LCD will scroll the all data from line 8 to 63 to the top of the screen &amp; what ever data is at the top from line 0 to 8 will be scrolled down to line 56 to 63.
<br />
What do you think is this analysis right?
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">By adjusting here it starts the frame scan in the buffer the entire display can be scrolled (try a for() loop incrementing the display start). </div>
<br />
I did not got about this statement, can you explain me exactly how should i procede to test this senario ?
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">As some bits &quot;fall off&quot; the screen you need to re-write those with the &quot;newline&quot; that appears - but it lets you scroll the display without having to rewrite the entire frame buffer</div>
<br />
Please clarify it a bit more ?<hr />
<b>katochd46</b> - Sep 12, 2010 - 11:22 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I have been sucessful in displaying the character in the form of 5x8 font size.
<br />

<br />
But now i want to display various other font, so i searched on net and found lib from Fabian Maximilian Thiele.
<br />

<br />
At present i am not able to understand from the library code how it is displaying the data &amp; how data is arranged in the .h file.
<br />

<br />
Can anyone tell me how the font data is arranged in file ariel_bold_14.h file.  If you can explain me about an single character 
<br />
'A' how to organise data for this character from this .h file .
<br />
Then i can easily get the concept behind this &amp; can write an code to display the characters in ariel bold format.
<br />

<br />
Please help me out.
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp;* File Name&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#58; arial_bold_14
<br />
&nbsp;* Date&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#58; 29.01.2005
<br />
&nbsp;* Font size in bytes&nbsp; &#58; 8712
<br />
&nbsp;* Font width&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &#58; 10
<br />
&nbsp;* Font height&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&#58; 14
<br />
&nbsp;* Font first char&nbsp; &nbsp; &nbsp;&#58; 32
<br />
&nbsp;* Font last char&nbsp; &nbsp; &nbsp; &#58; 128
<br />
&nbsp;* Font used chars&nbsp; &nbsp; &nbsp;&#58; 96
<br />
&nbsp;*
<br />
&nbsp;* The font data are defined as
<br />
&nbsp;*
<br />
&nbsp;* struct _FONT_ &#123;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;uint16_t&nbsp; &nbsp;font_Size_in_Bytes_over_all_included_Size_it_self;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;uint8_t&nbsp; &nbsp; font_Width_in_Pixel_for_fixed_drawing;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;uint8_t&nbsp; &nbsp; font_Height_in_Pixel_for_all_characters;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;unit8_t&nbsp; &nbsp; font_First_Char;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;uint8_t&nbsp; &nbsp; font_Char_Count;
<br />
&nbsp;*
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;uint8_t&nbsp; &nbsp; font_Char_Widths&#91;font_Last_Char - font_First_Char +1&#93;;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // for each character the separate width in pixels,
<br />
&nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // characters &lt; 128 have an implicit virtual right empty row
<br />
&nbsp;*
<br />
&nbsp;*&nbsp; &nbsp; &nbsp;uint8_t&nbsp; &nbsp; font_data&#91;&#93;;
<br />
&nbsp;*&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // bit field of all characters
<br />
&nbsp;*/
<br />

<br />
#include &lt;inttypes.h&gt;
<br />
#include &lt;avr/pgmspace.h&gt;
<br />

<br />
#ifndef ARIAL_BOLD_14_H
<br />
#define ARIAL_BOLD_14_H
<br />

<br />
#define ARIAL_BOLD_14_WIDTH 10
<br />
#define ARIAL_BOLD_14_HEIGHT 14
<br />

<br />
static uint8_t Arial_Bold_14&#91;&#93; PROGMEM = &#123;
<br />
&nbsp; &nbsp; 0x22, 0x08, // size
<br />
&nbsp; &nbsp; 0x0A, // width - 10&nbsp; &nbsp;i.e 10x14
<br />
&nbsp; &nbsp; 0x0E, // height - 14
<br />
&nbsp; &nbsp; 0x20, // first char
<br />
&nbsp; &nbsp; 0x60, // char count
<br />
&nbsp; &nbsp; 
<br />
&nbsp; &nbsp; // char widths
<br />
&nbsp; &nbsp; 0x04, 0x02, 0x05, 0x06, 0x07, 0x08, 0x09, 0x02, 0x03, 0x03, 
<br />
&nbsp; &nbsp; 0x05, 0x08, 0x02, 0x04, 0x02, 0x04, 0x07, 0x04, 0x07, 0x07, 
<br />
&nbsp; &nbsp; 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x02, 0x02, 0x07, 0x07, 
<br />
&nbsp; &nbsp; 0x07, 0x08, 0x0E, 0x09, 0x08, 0x08, 0x08, 0x07, 0x07, 0x09, 
<br />
&nbsp; &nbsp; 0x08, 0x02, 0x07, 0x08, 0x07, 0x0B, 0x08, 0x09, 0x07, 0x09, 
<br />
&nbsp; &nbsp; 0x09, 0x07, 0x08, 0x08, 0x09, 0x0D, 0x07, 0x08, 0x08, 0x04, 
<br />
&nbsp; &nbsp; 0x04, 0x04, 0x06, 0x08, 0x03, 0x07, 0x07, 0x06, 0x07, 0x07, 
<br />
&nbsp; &nbsp; 0x05, 0x07, 0x07, 0x02, 0x03, 0x06, 0x02, 0x0A, 0x07, 0x07, 
<br />
&nbsp; &nbsp; 0x07, 0x07, 0x05, 0x06, 0x05, 0x07, 0x07, 0x0B, 0x06, 0x07, 
<br />
&nbsp; &nbsp; 0x05, 0x05, 0x01, 0x05, 0x07, 0x08, 
<br />
&nbsp; &nbsp; 
<br />
&nbsp; &nbsp; // font data
<br />
&nbsp; &nbsp; 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x18, 0x18, // 33
<br />
&nbsp; &nbsp; 0x1E, 0x1E, 0x00, 0x1E, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, // 34
<br />
&nbsp; &nbsp; 0x90, 0xF8, 0x9E, 0x90, 0xF8, 0x9E, 0x1C, 0x00, 0x00, 0x1C, 0x00, 0x00, // 35
<br />
&nbsp; &nbsp; 0x18, 0x3C, 0x26, 0xFF, 0x66, 0xCC, 0x88, 0x04, 0x0C, 0x18, 0x3C, 0x18, 0x0C, 0x04, // 36
<br />
&nbsp; &nbsp; 0x1C, 0x22, 0x1C, 0xC0, 0x30, 0x8E, 0x40, 0x80, 0x00, 0x00, 0x18, 0x04, 0x00, 0x0C, 0x10, 0x0C, // 37
<br />
&nbsp; &nbsp; 0x80, 0xCC, 0x7E, 0x72, 0xF2, 0xDE, 0x0C, 0x80, 0x00, 0x0C, 0x1C, 0x10, 0x10, 0x10, 0x1C, 0x0C, 0x1C, 0x10, // 38
<br />
&nbsp; &nbsp; 0x1E, 0x1E, 0x00, 0x00, // 39
<br />
&nbsp; &nbsp; 0xF0, 0xFC, 0x06, 0x1C, 0x7C, 0xC0, // 40
<br />
&nbsp; &nbsp; 0x06, 0xFC, 0xF0, 0xC0, 0x7C, 0x1C, // 41
<br />
&nbsp; &nbsp; 0x14, 0x14, 0x0E, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, // 42
<br />
&nbsp; &nbsp; 0x60, 0x60, 0x60, 0xFC, 0xFC, 0x60, 0x60, 0x60, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x00, // 43
<br />
&nbsp; &nbsp; 0x00, 0x00, 0x58, 0x38, // 44
<br />
&nbsp; &nbsp; 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, // 45
<br />
&nbsp; &nbsp; 0x00, 0x00, 0x18, 0x18, // 46
<br />
&nbsp; &nbsp; 0x00, 0xC0, 0x38, 0x06, 0x18, 0x04, 0x00, 0x00, // 47
<br />
&nbsp; &nbsp; 0xF8, 0xFC, 0x0E, 0x06, 0x0E, 0xFC, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x1C, 0x0C, 0x04, // 48
<br />
&nbsp; &nbsp; 0x18, 0x0C, 0xFE, 0xFE, 0x00, 0x00, 0x1C, 0x1C, // 49
<br />
&nbsp; &nbsp; 0x18, 0x1C, 0x86, 0xC6, 0x66, 0x3E, 0x1C, 0x18, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, // 50
<br />
&nbsp; &nbsp; 0x88, 0x8C, 0x06, 0x26, 0x26, 0xFE, 0xDC, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x0C, 0x04, // 51
<br />
&nbsp; &nbsp; 0xC0, 0xE0, 0xB8, 0x8C, 0xFE, 0xFE, 0x80, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x1C, 0x04, // 52
<br />
&nbsp; &nbsp; 0x70, 0x7E, 0x3E, 0x36, 0x36, 0xF6, 0xC6, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x0C, 0x04, // 53
<br />
&nbsp; &nbsp; 0xF8, 0xFC, 0x6E, 0x66, 0x66, 0xEE, 0xCC, 0x04, 0x0C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 54
<br />
&nbsp; &nbsp; 0x06, 0x06, 0x06, 0xE6, 0x76, 0x1E, 0x06, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 55
<br />
&nbsp; &nbsp; 0x9C, 0xFE, 0x66, 0x66, 0x66, 0xFE, 0x9C, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 56
<br />
&nbsp; &nbsp; 0x3C, 0x7E, 0x66, 0x66, 0x66, 0xFC, 0xF8, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 57
<br />
&nbsp; &nbsp; 0x18, 0x18, 0x18, 0x18, // 58
<br />
&nbsp; &nbsp; 0x18, 0x18, 0x58, 0x38, // 59
<br />
&nbsp; &nbsp; 0x60, 0x60, 0xF0, 0xF0, 0x98, 0x98, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x0C, // 60
<br />
&nbsp; &nbsp; 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 61
<br />
&nbsp; &nbsp; 0x0C, 0x98, 0x98, 0xF0, 0xF0, 0x60, 0x60, 0x0C, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, // 62
<br />
&nbsp; &nbsp; 0x08, 0x0C, 0x06, 0xC6, 0xE6, 0x76, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, // 63
<br />
&nbsp; &nbsp; 0xE0, 0x30, 0x08, 0xC4, 0xF6, 0x3A, 0x1A, 0x1A, 0xF2, 0xFA, 0x7E, 0x04, 0x08, 0xF0, 0x0C, 0x30, 0x60, 0x4C, 0x9C, 0x98, 0x98, 0x8C, 0x9C, 0x9C, 0x90, 0x48, 0x4C, 0x20, // 64
<br />
&nbsp; &nbsp; 0x00, 0xC0, 0xF8, 0xBE, 0x86, 0xBE, 0xF8, 0xC0, 0x00, 0x18, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x18, // 65
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x66, 0x66, 0x66, 0x66, 0xFE, 0xDC, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 66
<br />
&nbsp; &nbsp; 0xF8, 0xFC, 0x0E, 0x06, 0x06, 0x0E, 0x9C, 0x08, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 67
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x06, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 68
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x66, 0x66, 0x66, 0x66, 0x66, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, // 69
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x66, 0x66, 0x66, 0x66, 0x06, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, // 70
<br />
&nbsp; &nbsp; 0xF8, 0xFC, 0x0E, 0x06, 0x06, 0xC6, 0xCE, 0xDC, 0xC8, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x0C, 0x04, // 71
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x60, 0x60, 0x60, 0x60, 0xFE, 0xFE, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, // 72
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x1C, 0x1C, // 73
<br />
&nbsp; &nbsp; 0x80, 0x80, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 74
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x60, 0x30, 0x78, 0xEC, 0x86, 0x02, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x04, 0x1C, 0x18, // 75
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, // 76
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x0E, 0x7C, 0xE0, 0x00, 0xE0, 0x7C, 0x0E, 0xFE, 0xFE, 0x1C, 0x1C, 0x00, 0x00, 0x0C, 0x1C, 0x0C, 0x00, 0x00, 0x1C, 0x1C, // 77
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x1C, 0x78, 0xE0, 0x80, 0xFE, 0xFE, 0x1C, 0x1C, 0x00, 0x00, 0x04, 0x0C, 0x1C, 0x1C, // 78
<br />
&nbsp; &nbsp; 0xF8, 0xFC, 0x0E, 0x06, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 79
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x66, 0x66, 0x66, 0x7E, 0x3C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, // 80
<br />
&nbsp; &nbsp; 0xF8, 0xFC, 0x0E, 0x06, 0x86, 0x06, 0x0E, 0xFC, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x1C, 0x24, // 81
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x66, 0x66, 0xE6, 0xE6, 0xBE, 0x1C, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x0C, 0x1C, 0x18, 0x10, // 82
<br />
&nbsp; &nbsp; 0x3C, 0x7E, 0x66, 0x66, 0x66, 0xEE, 0xCC, 0x0C, 0x1C, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 83
<br />
&nbsp; &nbsp; 0x06, 0x06, 0x06, 0xFE, 0xFE, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 84
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x04, 0x0C, 0x1C, 0x18, 0x18, 0x1C, 0x0C, 0x04, // 85
<br />
&nbsp; &nbsp; 0x02, 0x1E, 0xFC, 0xE0, 0x00, 0xE0, 0xFC, 0x1E, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 86
<br />
&nbsp; &nbsp; 0x06, 0xFE, 0xF8, 0x00, 0xF0, 0xFE, 0x0E, 0xFE, 0xF0, 0x00, 0xF8, 0xFE, 0x06, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, // 87
<br />
&nbsp; &nbsp; 0x06, 0x0E, 0xF8, 0xF0, 0xF8, 0x0E, 0x06, 0x18, 0x1C, 0x04, 0x00, 0x04, 0x1C, 0x18, // 88
<br />
&nbsp; &nbsp; 0x06, 0x0E, 0x38, 0xF0, 0xF0, 0x38, 0x0E, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 89
<br />
&nbsp; &nbsp; 0x06, 0x06, 0x86, 0xE6, 0x76, 0x1E, 0x0E, 0x06, 0x18, 0x1C, 0x1C, 0x18, 0x18, 0x18, 0x18, 0x18, // 90
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x06, 0x06, 0xFC, 0xFC, 0xC0, 0xC0, // 91
<br />
&nbsp; &nbsp; 0x06, 0x38, 0xC0, 0x00, 0x00, 0x00, 0x04, 0x18, // 92
<br />
&nbsp; &nbsp; 0x06, 0x06, 0xFE, 0xFE, 0xC0, 0xC0, 0xFC, 0xFC, // 93
<br />
&nbsp; &nbsp; 0x20, 0x38, 0x0E, 0x0E, 0x38, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 94
<br />
&nbsp; &nbsp; 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, // 95
<br />
&nbsp; &nbsp; 0x02, 0x06, 0x04, 0x00, 0x00, 0x00, // 96
<br />
&nbsp; &nbsp; 0x10, 0x98, 0xD8, 0x58, 0xF8, 0xF0, 0x00, 0x0C, 0x1C, 0x18, 0x18, 0x0C, 0x1C, 0x10, // 97
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x30, 0x18, 0x38, 0xF0, 0xE0, 0x1C, 0x1C, 0x0C, 0x18, 0x1C, 0x0C, 0x04, // 98
<br />
&nbsp; &nbsp; 0xE0, 0xF0, 0x18, 0x18, 0x38, 0x30, 0x04, 0x0C, 0x18, 0x18, 0x1C, 0x0C, // 99
<br />
&nbsp; &nbsp; 0xE0, 0xF0, 0x38, 0x18, 0x30, 0xFE, 0xFE, 0x04, 0x0C, 0x1C, 0x18, 0x0C, 0x1C, 0x1C, // 100
<br />
&nbsp; &nbsp; 0xE0, 0xF0, 0xD8, 0xD8, 0xD8, 0xF0, 0xE0, 0x04, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x08, // 101
<br />
&nbsp; &nbsp; 0x18, 0xFC, 0xFE, 0x1A, 0x1A, 0x00, 0x1C, 0x1C, 0x00, 0x00, // 102
<br />
&nbsp; &nbsp; 0xE0, 0xF0, 0x38, 0x18, 0x30, 0xF8, 0xF8, 0x64, 0xEC, 0xDC, 0xD8, 0xCC, 0xFC, 0x7C, // 103
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x30, 0x18, 0x18, 0xF8, 0xF0, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x1C, // 104
<br />
&nbsp; &nbsp; 0xFA, 0xFA, 0x1C, 0x1C, // 105
<br />
&nbsp; &nbsp; 0x00, 0xFA, 0xFA, 0xC0, 0xFC, 0x7C, // 106
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0xE0, 0xF0, 0x98, 0x08, 0x1C, 0x1C, 0x00, 0x04, 0x1C, 0x18, // 107
<br />
&nbsp; &nbsp; 0xFE, 0xFE, 0x1C, 0x1C, // 108
<br />
&nbsp; &nbsp; 0xF8, 0xF8, 0x10, 0x18, 0xF8, 0xF0, 0x18, 0x18, 0xF8, 0xF0, 0x1C, 0x1C, 0x00, 0x00, 0x1C, 0x1C, 0x00, 0x00, 0x1C, 0x1C, // 109
<br />
&nbsp; &nbsp; 0xF8, 0xF8, 0x30, 0x18, 0x18, 0xF8, 0xF0, 0x1C, 0x1C, 0x00, 0x00, 0x00, 0x1C, 0x1C, // 110
<br />
&nbsp; &nbsp; 0xE0, 0xF0, 0x38, 0x18, 0x38, 0xF0, 0xE0, 0x04, 0x0C, 0x1C, 0x18, 0x1C, 0x0C, 0x04, // 111
<br />
&nbsp; &nbsp; 0xF8, 0xF8, 0x30, 0x18, 0x38, 0xF0, 0xE0, 0xFC, 0xFC, 0x0C, 0x18, 0x1C, 0x0C, 0x04, // 112
<br />
&nbsp; &nbsp; 0xE0, 0xF0, 0x38, 0x18, 0x30, 0xF8, 0xF8, 0x04, 0x0C, 0x1C, 0x18, 0x0C, 0xFC, 0xFC, // 113
<br />
&nbsp; &nbsp; 0xF8, 0xF8, 0x30, 0x18, 0x18, 0x1C, 0x1C, 0x00, 0x00, 0x00, // 114
<br />
&nbsp; &nbsp; 0x70, 0xF8, 0xD8, 0xD8, 0xD8, 0x90, 0x08, 0x18, 0x18, 0x18, 0x1C, 0x0C, // 115
<br />
&nbsp; &nbsp; 0x18, 0xFC, 0xFE, 0x18, 0x18, 0x00, 0x0C, 0x1C, 0x18, 0x18, // 116
<br />
&nbsp; &nbsp; 0xF8, 0xF8, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x0C, 0x1C, 0x18, 0x18, 0x0C, 0x1C, 0x1C, // 117
<br />
&nbsp; &nbsp; 0x38, 0xF8, 0xC0, 0x00, 0xC0, 0xF8, 0x38, 0x00, 0x00, 0x1C, 0x1C, 0x1C, 0x00, 0x00, // 118
<br />
&nbsp; &nbsp; 0x18, 0xF8, 0xE0, 0x00, 0xF0, 0x38, 0xF0, 0x00, 0xE0, 0xF8, 0x18, 0x00, 0x00, 0x1C, 0x1C, 0x0C, 0x00, 0x0C, 0x1C, 0x1C, 0x00, 0x00, // 119
<br />
&nbsp; &nbsp; 0x18, 0x38, 0xE0, 0xE0, 0x38, 0x18, 0x18, 0x1C, 0x04, 0x04, 0x1C, 0x18, // 120
<br />
&nbsp; &nbsp; 0x18, 0xF8, 0xE0, 0x00, 0xE0, 0xF8, 0x18, 0x00, 0x84, 0xFC, 0xF8, 0x3C, 0x04, 0x00, // 121
<br />
&nbsp; &nbsp; 0x18, 0x98, 0xD8, 0x78, 0x38, 0x1C, 0x1C, 0x18, 0x18, 0x18, // 122
<br />
&nbsp; &nbsp; 0x80, 0xFC, 0x7E, 0x06, 0x06, 0x00, 0x7C, 0xFC, 0xC0, 0xC0, // 123
<br />
&nbsp; &nbsp; 0xFE, 0xFC, // 124
<br />
&nbsp; &nbsp; 0x06, 0x06, 0x7E, 0xFC, 0x80, 0xC0, 0xC0, 0xFC, 0x7C, 0x00, // 125
<br />
&nbsp; &nbsp; 0x60, 0x30, 0x30, 0x70, 0x60, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 126
<br />
&nbsp; &nbsp; 0xFE, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0xFE, 0x1C, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1C // 127
<br />
&nbsp; &nbsp; 
<br />
&#125;;</div><hr />
<b>clawson</b> - Sep 12, 2010 - 02:16 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Well 'A' is 65. So I guess the data is:
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">0x00, 0xC0, 0xF8, 0xBE, 0x86, 0xBE, 0xF8, 0xC0, 0x00, 0x18, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1C, 0x18, // 65 </div>
<br />
I'd get out some graph paper and colour in the blobs and see if you can spot the A in there. To get you started
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">00000000
<br />
11000000
<br />
11111000
<br />
10111100
<br />
10000110
<br />
10111100
<br />
11111000
<br />
11000000
<br />

<br />
00000000
<br />
00011000
<br />
00011100
<br />
00000100
<br />
00000100
<br />
00000100
<br />
00000100
<br />
00000100
<br />
00011100
<br />
00011000</div>
<br />
Now see if you can re-arrange that jigsaw to look like an A
<br />

<br />
EDIT: looking at that - tilt your head over to the right - looks a lot like an A on its side to me in two halves with the second half only using the upper 6 of 8 bits.<hr />
<b>katochd46</b> - Sep 12, 2010 - 04:06 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
thanks clawson, for the guess
<br />

<br />
I am able to get the logic. means if width is 8 for an character then array is having 16 caracter in it.
<br />
Use the 8 bit of the first 8 caracter directly &amp; for the next 8 byte use only the first 6 bits that to right shift by 2.
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">this data is for A --- last half bytes right shift by 2
<br />
000000000
<br />
000111000
<br />
000111000
<br />
001101100
<br />
001101100
<br />
001101100
<br />
011000110
<br />
011111110
<br />
011111110
<br />
110000011
<br />
110000011
<br />
000000000
<br />
000000000
<br />
000000000
<br />

<br />
if&#40;height &lt; &#40;i+1&#41;*8&#41; &#123;
<br />
&nbsp; &nbsp; &nbsp;data &gt;&gt;= &#40;i+1&#41;*8-height;
<br />
&#125;
<br />
Means right shift by 2
<br />
Last half byte without right shift
<br />
000000000
<br />
000000000
<br />
011111110
<br />
110000011
<br />
110000011
<br />
000000000
<br />
&nbsp;
<br />
&nbsp;
<br />
this data is for B --- last half bytes right shift by 2
<br />
00000000
<br />
11111110
<br />
11111111
<br />
11000011
<br />
11000011
<br />
11111110
<br />
11111111
<br />
11000011... 
<br />
11000011
<br />
11111111
<br />
11111111
<br />
00111100
<br />
00000000
<br />
00000000
<br />
if&#40;height &lt; &#40;i+1&#41;*8&#41; &#123;
<br />
&nbsp; &nbsp; &nbsp;data &gt;&gt;= &#40;i+1&#41;*8-height;
<br />
&#125;
<br />
Means right shift by 2
<br />
Last half byte without right shift
<br />
00000000
<br />
00000000
<br />
11000011
<br />
11111111
<br />
11111111
<br />
00111100</div>
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">As in your previous post you told about word scrolling, and yes you were very right data was scrolling from top to bottom.</div>
<br />
But what is advantage of this kind of behaviour ?<hr />
<b>clawson</b> - Sep 12, 2010 - 04:38 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
But what is advantage of this kind of behaviour ?
<br />
</div>
<br />
Not having to rewrite the entire frame buffer to scroll.<hr />
<b>bperrybap</b> - Sep 12, 2010 - 09:54 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
A few things to note about thieles character data format.
<br />

<br />
The byte size field in the front of the structure is CRAP.
<br />
It is a simple bug, the FontCreator Java code miscalculated it. It's an easy fix, but as is, it is not useful for anything.
<br />

<br />
Also that the data for fraction bytes is (IMHO) shifted backwards. I think this was in fact a bug
<br />
in his FontCreator java code that generates the .h files.
<br />
If you look carefully, you will see a funky shift in his rendering routine.
<br />
This is a total PITA.
<br />
(And while I wrote code to support it, I totally detest it).
<br />
It is only a 2 line change to the FontCreator java code to
<br />
fix it which is why I think think it was a bug rather
<br />
than &quot;by design&quot;.
<br />

<br />
Here is how it works.
<br />
(For this I'll ignore any leading, kerning, spacing etc..)
<br />
Suppose the Font is 14 pixels tall. This means that there is only 14 of the 16 bits
<br />
of the two data bytes per column that are valid font data.
<br />
Pixels on the ks0108 start high and advance down. i.e. bit 0 is top pixel of  a page
<br />
and bit 7 is bottom pixel of a page.
<br />

<br />
So consider what happens for a 14 pixel tall font. Since not all 16 bits are used,
<br />
you have to decide how to handle the unused 2 bits.
<br />
If you look at it linearly as a 16 bit tall chuck of data,
<br />
you would have 14 bits of data going from bit 0 to bit 13 down the display
<br />
and in lcd page memory, assuming you are on a lcd page
<br />
boundary, you would have bits 0-7 of data store in the top page and then bits 8-13 of the data stored in bits 0-5 of the lower page.
<br />

<br />
The problem you run into is that Thiele's font format shifted the bits for fractional bytes backwards. 
<br />
What this means is that in the 14 pixel tall font
<br />
the lower 6 pixels are not stored in bits 0-5 of 
<br />
the font data byte as are needed to write to the glcd page, they are in bits 2-7
<br />

<br />
Thiele's java font creator tools (which creates the .h font files), shifts remaining bits of a byte to the high end of the byte instead of leaving them alone.
<br />
Because of this, the data for fraction bytes is incompatible with ks0108 glcd pages and must be shifted back down before it is or'd/stored into the glcd page.
<br />

<br />
If you look at his ks0108PutChar() function
<br />
you will this code:
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">if&#40;height &lt; &#40;i+1&#41;*8&#41; &#123;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;data &gt;&gt;= &#40;i+1&#41;*8-height;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;</div>
<br />
That code is runtime checking for and doing the shift for fractional bytes.
<br />
The amount of shift is based on how many valid bits there
<br />
are. For example, if there is only 1 valid bit,
<br />
the shift is 7, 2 it will be 6, and if 6 then it is 2.
<br />

<br />
Another thing to watch out for, is that while
<br />
Thiele's font rendering routine does work for
<br />
certain situations, it is too simple and has many issues.
<br />

<br />
The code tried to be simple and elegant by trying to get the WriteData() routine to handle the vertical page crossings so that upper layers could simply do writes and not have to worry about it.
<br />
Well the problem is that WriteData() interface is an 8 bit interface and the character rendering routine needs to be able to write less than 8 bits sometimes.
<br />
To deal with this, the WriteData() routine attempts to OR in data bits when the 8 bit data spans vertical lcd pages.
<br />
This creates an inconsistent behavior depending if the data is being written to to a full page or spans pages.
<br />

<br />
So for example, if you call WriteData() with the value of 0xAB and the Y coordinate is 4 (non modulo <img src="modules/PNphpBB2/images/smiles/icon_cool.gif" alt="Cool" border="0" />, then 0xA is ORd in to the lower nibble of the upper page and 0xB is ORd in the upper nibble of the upper page.
<br />
But if you write that same 0xAB when Y coordinate is 8 (modulo <img src="modules/PNphpBB2/images/smiles/icon_cool.gif" alt="Cool" border="0" />, then 0xAB is WRITTEN not ORd to the lcd page.
<br />

<br />
This creates problems when rendering fonts that are not exact multiples of of 8 in height as depending on the leading (vertical spacing), you may end up stomping on part of the character (or graphics) either just above or below the glyph depending on the Y coordinate because depending on the alignment, the data is sometimes OR'd in and sometimes STORED in the glcd page(s).
<br />
The problem is aggravated the further from modulo 8 in size you are. I.e. fonts of 9, 17, 25, etc. will have the most issues.
<br />

<br />
While I do support Thiele's existing font format with the backwards shift, I wrote my own rendering routines so that I could consistently and reliably render any sized font on any boundary and support automatic wrapping and scrolling within user define text areas.
<br />

<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 13, 2010 - 08:02 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Thanks bill for the detailed explanation. Now it is very clear to me.
<br />
Then i should keep this piece of code same for right shift by 2.
<br />

<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So for example, if you call WriteData() with the value of 0xAB and the Y coordinate is 4 (non modulo , then 0xA is ORd in to the lower nibble of the upper page and 0xB is ORd in the upper nibble of the upper page.</div> 
<br />
I also tried this thing but was not successful, i just want to know the command to shift the y cordinate (i.e suppose i want my starting row to be the 4 th row, from where i have to start display of my caracter)
<br />

<br />
What is the concept behind this ? 
<br />
Do the data inserstion always starts at an starting line for an page ?
<br />

<br />
Please suggest is this below logic right, or i can do it in some other way ?
<br />
So in this case suppose i want to put an hex value 0xAB, in last 4 line of page 0 &amp; first 4 line of page 1.
<br />
so here lower nibble i 0xB0 so this should be send to page zero. It will go and occupy last 4 line of page 1
<br />
And higher nibble i 0x0A so this should be send to page zero. It will go and occupy first 4 line of page 1.
<br />

<br />
Initially i thought Dispay_start_line command will do this for us but it is doing the scrolling for me.<hr />
<b>katochd46</b> - Sep 13, 2010 - 02:10 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
Bill/calwson,
<br />

<br />
I am waiting for your reply, related to last post.
<br />

<br />
Please suggest.<hr />
<b>clawson</b> - Sep 13, 2010 - 02:15 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I think you'll have to wait for Bill's country to wake up. I don't know this LCD controller specifically and do not know what the frame buffer layout is. All I can tell you is that whenever I'm first writing low level driver code for a new GLCD what I inevitably do is sketch out a grid on a piece of paper to show the bitmap layout annotated with line and column addressing to work out what the X and Y character cell offsets are.<hr />
<b>katochd46</b> - Sep 13, 2010 - 05:15 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
I am able to display font, just one statement change in the code to adapt it with my org code.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I think you'll have to wait for Bill's country to wake up.</div>
<br />
yes you are right <img src="modules/PNphpBB2/images/smiles/icon_smile.gif" alt="Smile" border="0" />
<br />
Lets wait from some feedback from bill then i will proceed.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">All I can tell you is that whenever I'm first writing low level driver code for a new GLCD what I inevitably do is sketch out a grid on a piece of paper to show the bitmap layout annotated with line and column addressing to work out what the X and Y character cell offsets are.</div>
<br />
good idea, but i found an link that we can use simulator for KS0108B LCd, but i am not getting how our C code  can communicate with it.
<br />
<a href="http://www.scienceprog.com/simulate-ks0108-graphical-lcd-with-proteus-simulator/" target="_blank" class="postlink">http://www.scienceprog.com/simulate-ks0108-graphical-lcd-with-proteus-simulator/</a>
<br />

<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">By adjusting here it starts the frame scan in the buffer the entire display can be scrolled (try a for() loop incrementing the display start).</div>
<br />
I  tried this option yes dipay is scrolling single line a time. But shifting is so fast that you cannot see the single line shifting, even if yo give 10 sec delay between shift of two line. 
<br />
I dont know why ?
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp;//loop to check the scrolling effect on G-Lcd 
<br />
&nbsp; &nbsp;for&#40;i=0; i&lt;KS0108_PAGE_THREE_Y; i++&#41;;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;// i.e 128x64 lcd so in this out of 64 which line to go for starting position -- Srolling
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | i, CHIP2&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ks0108WriteCommand&#40;LCD_DISP_START | i, CHIP1&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;for&#40; j=0; j&lt;2000; j++&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;_delay_ms&#40;10000&#41;;
<br />
&#125;</div><hr />
<b>bperrybap</b> - Sep 13, 2010 - 05:42 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
There are a few other ks0108 threads where I've
<br />
commented on Thiele's code as well as Sami Varjo's code
<br />
in SourceForge. Here is a link to one of those threads:
<br />
(Search for ks0108 and use my login &quot;bperrybap&quot; to find them all)
<br />
<a href="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=83287" target="_blank" class="postlink">http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;t=83287</a>
<br />

<br />
Sami's code has some good example code that demonstrates
<br />
some of the ks0108 capabilities such as the set starting line and display on/off.
<br />

<br />
If you want to play with an Arduino glcd library,
<br />
have a look at this library:
<br />
<a href="http://www.arduino.cc/playground/Code/GLCDks0108" target="_blank" class="postlink">http://www.arduino.cc/playground/Code/GLCDks0108</a>
<br />
I was heavily involved with the new version (currently in Beta) and did the low level and text area code.
<br />

<br />
But to keep things going,
<br />
here is some additional detail on the memory layout of a ks0108.
<br />
Here is a link to a typical ks0108 data sheet:
<br />
<a href="http://docs.bgmicro.com/pdf/lcd1030.pdf" target="_blank" class="postlink">http://docs.bgmicro.com/pdf/lcd1030.pdf</a>
<br />

<br />
One thing to keep in mind is that the ks0108 is really  a single chip that runs a 64x64 pixel array.
<br />
A &quot;ks0108&quot; glcd module typically has more than one of these chips on it so you have to talk to all of them
<br />
(individually) to address all the pixels on the display.
<br />

<br />
Another thing that can get confusing is that the terms &quot;X&quot; and &quot;Y&quot; are backwards in the documentation from a &quot;normal&quot; coordinate system if the display is positioned where it is wider than it is tall - which is the most common orientation.
<br />

<br />
In ks0108 module documenation, &quot;X&quot; addresses are vertical and &quot;Y&quot; addresses are horizontal.
<br />
So I will always use the terms &quot;Set Column&quot; instead of &quot;Set Y address&quot; and &quot;Set Page&quot; instead of &quot;Set X address&quot;
<br />
when referring to hardware/chip addresses to remove confusion between the software X &amp; Y coordinates and the hardware X &amp; Y addresses since they are backwards from each other.
<br />
My advice here is to totally ignore any references to &quot;X&quot; and &quot;Y&quot; in ks0108 documentation and stick with &quot;page&quot; and &quot;column&quot; instead.
<br />

<br />
As far as memory mapping to pixel goes,
<br />
On a 64x128 assuming in the wider than tall orientation
<br />
(which is what most code including, Thiele's and Sami's code assume),
<br />
The pixels &quot;by default&quot; will map as follows.
<br />
LCD pages which are set with the &quot;Set Page&quot; command (0b10111000 | page).
<br />
Pages go from 0 to 7 with 0 being at the top.
<br />
Each page is 8 bits and corresponds to 8 vertical pixels with bit 0 being at the top.
<br />
For the horizontal position, the &quot;Set Address&quot; or &quot;Set Column&quot; command is used: (0b01000000 | column)
<br />

<br />
What this means is that the final coordinate system
<br />
is not a normal Cartesian coordinate system.
<br />
The ks0108 coordinate system places 0,0 in the upper
<br />
left corner with Y values advancing down and X values
<br />
advancing to the right. While this may sound odd/strange
<br />
java also uses this system by default.
<br />

<br />
But keep in mind that while X values (on a 64x128 display) will advance from 0 to 127, the actual column values will not. They will increment from 0 to 63 and then back to 0 to 63 again as you cross into the next chip.
<br />
i.e X value 64 is column 0 on the right ks0108 chip.
<br />

<br />
Also, &quot;Y values&quot; don't really exist in the hardware.
<br />
The hardware is page based and so any support for a Y coordinate value must be handled by software
<br />
because the hardware is paged based you cannot set individual pixels and must always write a full 8 bits/pixels. Software must deal with this by potentially doing additional reads/writes to set the proper pixels.
<br />

<br />
The &quot;Display Start Line&quot; command allows the display to be rolled around. So if you set it to 1, the top line of pixels will skipped so it ends up being moved to the bottom of the display.
<br />
The intent of this is to allow scrolling by being able to pick the starting pixel row that is at the top of the display.
<br />
But even though the &quot;start line&quot; command allows selecting an individual pixel row, the module is still page based.
<br />

<br />
Neither Thiele's nor Sami's code supported scrolling so they kind of punted on the scrolling issue.
<br />
I don't think Thiele's code even supported wrapping.
<br />

<br />
I don't use &quot;start line&quot; capability as it does not work when intermixing text with graphics. My code also supports user defined scrollable text areas, including multiple text areas, which can independently be scrolled so it does not work for that either.
<br />

<br />
Well, it could be made to work since the starting line can be set independently for each chip, so you could do graphics one chip and scrolling text on the other but that places certain restrictions on the display that I didn't want, so 
<br />
may view is that this capability is only useful if you are only going to do text as a single text area on the full display. Anything else, and this capability is not usable.
<br />

<br />
I handle all the scrolling in software by reading and then re-writing the necessary to move the pixel data up or down for scrolling.
<br />

<br />
Most GLCD libraries take care of all the page and column addressing for you. That is the value of the library.
<br />
So to draw characters on the screen, normally you issue some sort of GotoXY() type of primitive, then use some sort of PutChar() function to display the desired text.
<br />

<br />
Thiele's, Sami's, and the Arduino glcd library all work this way so it is quite easy to position text where you want.
<br />
And the above 3 libraries all have demo programs that demonstrate how to do this.
<br />

<br />
The biggest differences in the libraries, come down to how fonts are handled as well as things like wrapping and scrolling.
<br />

<br />

<br />
Did that help clear things up?
<br />

<br />
Hmmm. I guess maybe I should create a tutorial for the ks0108?
<br />

<br />
--- bill<hr />
<b>bperrybap</b> - Sep 13, 2010 - 06:07 PM<br />
<b>Post subject: </b>Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interface<hr class="sep"/>
<div class="quotetitle">katochd46 wrote:</div><div class="quotecontent">
<br />
Please suggest is this below logic right, or i can do it in some other way ?
<br />
So in this case suppose i want to put an hex value 0xAB, in last 4 line of page 0 &amp; first 4 line of page 1.
<br />
so here lower nibble i 0xB0 so this should be send to page zero. It will go and occupy last 4 line of page 1
<br />
And higher nibble i 0x0A so this should be send to page zero. It will go and occupy first 4 line of page 1.
<br />

<br />
Initially i thought Dispay_start_line command will do this for us but it is doing the scrolling for me.</div>
<br />

<br />
In order to do this, you will have to:
<br />
- read page 0 into a tempvar
<br />
- mask tempvar to remove bits that you want to set
<br />
- move your data byte in to tempvar2
<br />
- mask tempvar2 to keep only the bits needed for page 0
<br />
- OR tempvar and tempvar2 together
<br />
- write out the ORd value to page 0.
<br />
(repeat for page 1)
<br />

<br />
Not pretty but that is what has to happen.
<br />

<br />
The concept behind the misaligned page code in Thiele's
<br />
WriteData() was that you could simply do a 
<br />
GotoXY() to set the Y value to 4 and then do a
<br />
call to WriteData() with the 0xAB.
<br />
The WriteData() code would detect that the Y value was not on a page boundary and properly split the byte to put the needed bits into the two pages.
<br />
This could work; however, the WriteData() code does not do the masking to SET the bits. It simple ORs in the data bits.
<br />
This works for some situations but not for many others.
<br />
The code can be fixed to do the proper masking to set the bits vs ORing in the bits but then the font rendering code breaks because as mentioned before it calls WriteData() with 8 bit values when not all 8 bits are &quot;valid&quot; and is only wanting to set the &quot;1&quot; bits vs all 8 bits in the page.
<br />
This is why I wrote my own font rendering routines.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 14, 2010 - 06:28 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD interfa<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Did that help clear things up?</div>Thanks bill, it have totally clarified all the limitation of LCD.
<br />

<br />
Also one more thing left that -- 
<br />
Till yet i have tried only write data in that case the LCD auto increment the coulmn after writting.
<br />

<br />
If we perform read data then also the coulmn use to auto-increment <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />

<br />
If this this is the case then we have to read data then do proper masking as per your req. Then again set the column by decrementing the column value by 1. Then send your data.
<br />

<br />
Please correct me.
<br />

<br />

<br />
Also i am having two more doubts in thiele library :---
<br />
1&gt; schiefe line drawing --- 
<br />
what do we mean by schiefe line  <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />
what is the significance of this formulae &amp; how is it working. I think he is finding the slope of the line ? why is he using 200 is it his own assumption  <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;y2-y1&#41; &gt;= &#40;x2-x1&#41; || &#40;y1-y2&#41; &gt;= &#40;x2-x1&#41;&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// x1 must be smaller than x2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;x1 &gt; x2&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;xTmp = x1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;yTmp = y1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;x1 = x2;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;y1 = y2;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;x2 = xTmp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;y2 = yTmp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;length = x2-x1;&nbsp; &nbsp;&nbsp; &nbsp;// not really the length &#58;&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;m = &#40;&#40;y2-y1&#41;*200&#41;/length;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;yAlt = y1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for&#40;i=0; i&lt;=length; i++&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;y = &#40;&#40;m*i&#41;/200&#41;+y1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;&#40;m*i&#41;%200 &gt;= 100&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;y++;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if&#40;&#40;m*i&#41;%200 &lt;= -100&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;y--;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ks0108DrawLine&#40;x1+i, yAlt, x1+i, y, color&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if&#40;length &lt;= &#40;y2-y1&#41; &amp;&amp; y1 &lt; y2&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;yAlt = y+1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if&#40;length &lt;= &#40;y1-y2&#41; &amp;&amp; y1 &gt; y2&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;yAlt = y-1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;yAlt = y;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;</div>
<br />
2&gt; ks0108DrawRoundRect drawing --- I got how is it working it is drawing first four ARC at the four corner of the rectangle.
<br />
But waht is the significance of this formulae for tSwitch . Is it some standard formulae or his own assumption <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">tSwitch = 3 - 2 * radius; 
<br />
.....
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp; if &#40;tSwitch &lt; 0&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;tSwitch += &#40;4 * x1 + 6&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &#125; else &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;tSwitch += &#40;4 * &#40;x1 - y1&#41; + 10&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp;y1--;
<br />
&nbsp; &nbsp;&nbsp; &nbsp; &#125;</div>
<br />

<br />

<br />
If we create this kind of library which is capable of masking &amp; again writing back same data. 
<br />
So we can use this kind of concept to create some kind of video game like snake, space commando <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />

<br />

<br />
If you can answer these question it will be very helpful, from the concept point of view.<hr />
<b>bperrybap</b> - Sep 14, 2010 - 07:32 PM<br />
<b>Post subject: </b>Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD int<hr class="sep"/>
<div class="quotetitle">katochd46 wrote:</div><div class="quotecontent">
<br />
Also one more thing left that -- 
<br />
Till yet i have tried only write data in that case the LCD auto increment the coulmn after writting.
<br />

<br />
If we perform read data then also the coulmn use to auto-increment <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />

<br />
If this this is the case then we have to read data then do proper masking as per your req. Then again set the column by decrementing the column value by 1. Then send your data.
<br />
</div>
<br />

<br />
Yes you are correct.
<br />
Any read or write operation will increment the internal address of the ks0108 chip.
<br />
So to modify the data a page you will have to reset
<br />
the address before you write out the new data.
<br />

<br />
What Thiele's, Sami's, and the code I wrote do is to
<br />
run the s/w interface in what I call a &quot;hybrid&quot; mode.
<br />
From an API perspective the hardware address increments
<br />
on writes on but not on reads.
<br />
While this may seem odd, in real life applications it works out very well.
<br />
Here is how it works.
<br />
If you do a GotoXY() to a particular location and do
<br />
a ReadData() you get the page data at that location.
<br />
If you were to immediately do another ReadData() you
<br />
would get the very same data because the library
<br />
code backed up the address pointer to the same location
<br />
it was prior to ReadData().
<br />
This is not the case on writes.
<br />
So if you do a GotoXY() and do a WriteData(),
<br />
the write will write to the desired location but
<br />
if you were to do another WriteData() the write
<br />
would write to the *next* location not the same location.
<br />
Turns out that this is very useful for real life situations.
<br />
This allows things like what you see in the
<br />
SetDot() routine.
<br />
Which basically does a ReadData() modify data WriteData().
<br />
Note there is no code in SetDot() to set the address back, because the ReadData()
<br />
[actually it is done in the dummy read function DoReadData() ] sets the address back.
<br />

<br />
This also allows things like quickly setting blocks
<br />
of pages because you can do back to back WriteData() and the address *is* allowed to increment.
<br />

<br />
This &quot;hybrid&quot; mode is useful because in real life, whenever a page is read,
<br />
it was only read because it needs to be modified. And so that is why it is very useful
<br />
to go ahead and have the ReadData() function restore the hardware address.  While it is different behavior than  WriteData() it simplifies things for the application.
<br />

<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Also i am having two more doubts in thiele library :---
<br />
1&gt; schiefe line drawing --- 
<br />
what do we mean by schiefe line  <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />
what is the significance of this formulae &amp; how is it working. I think he is finding the slope of the line ? why is he using 200 is it his own assumption  <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />
</div>
<br />

<br />
I don't use Thiele's line drawing routines.
<br />
They were quite large and not nearly as fast as a simple
<br />
Bresenham function.
<br />
<a href="http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm" target="_blank" class="postlink">http://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm</a>
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
If we create this kind of library which is capable of masking &amp; again writing back same data. 
<br />
So we can use this kind of concept to create some kind of video game like snake, space commando <img src="modules/PNphpBB2/images/smiles/icon_question.gif" alt="Question" border="0" /> 
<br />
</div>
<br />

<br />
Theiele's library does include some functions to do
<br />
this with the functions like SetDot() etc.
<br />
Sami's library has a few more functions,
<br />
and the new version of Arduino glcd library is much more feature rich with full API documentation in HTML with full links and searching.
<br />

<br />
In fact, there is even a Rocket/Space game included
<br />
as one of the examples with the arduino glcd library.
<br />

<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 16, 2010 - 02:02 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD<hr class="sep"/>
thanks bill, yes you are right that it is Bresenham function, 
<br />

<br />
can you tell about some other algorithms that are commonly used for creation of :--
<br />
curves, arc, triangle, polygon, ecliips.
<br />

<br />
Because these are the most common thing needed to design an grapics design.
<br />

<br />
It will be helpful to enhance my knowlege and skills.<hr />
<b>clawson</b> - Sep 16, 2010 - 02:23 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD<hr class="sep"/>
You may want to look at Bezier:
<br />

<br />
<!-- m --><a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">http://en.wikipedia.org/wiki/B%C3%A9zier_curve</a><!-- m --><hr />
<b>katochd46</b> - Sep 17, 2010 - 03:34 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">You may want to look at Bezier: 
<br />

<br />
<!-- m --><a href="http://en.wikipedia.org/wiki/B%C3%A9zier_curve" target="_blank">http://en.wikipedia.org/wiki/B%C3%A9zier_curve</a><!-- m --> </div>
<br />
thankf for the details, clawson
<br />

<br />

<br />
hello bill, i compiled the Sami Varjo library &amp; changed the port as per my req, but none of the function is  working properly.
<br />

<br />
I found that command is same for KS0107 &amp; KS0108.
<br />

<br />
Please suggest ?
<br />

<br />
But i took the line drawing algo &amp; cirle drawing algo from the sammi library &amp; integrated into Fabian Maximilian Thiele' library it is working. I am able to draw the circle &amp; line as per my will.
<br />

<br />
But when i integrated the cirle fill &amp; clear algo is only working if circle is on the left hand side means on left chip but it is not atall working for right chip, if half my circle is on left chip &amp; other half is on right chip, only left half will be displayed.
<br />
As we know in code circle fill is calling fill line function &amp; fill line function is calling set dot function &amp; it is the function which is writing to LCD.
<br />

<br />
In mt case i am using the ks0108SetDot from the Thiele
<br />
library, as i have integrated the algo in the thiele library. But this function have been working fine for me so far.
<br />

<br />
If the problem would have been with chip select then the empty cirle would have not drawn.
<br />

<br />
I have attached my code.
<br />
Please suggest how to make it working?
<br />

<br />
Header file :---
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">// Ports
<br />
#define LCD_CMD_PORT&nbsp; &nbsp;&nbsp; &nbsp;PORTD&nbsp; &nbsp;&nbsp; &nbsp;// Command Output Register
<br />
#define LCD_CMD_DIR&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;DDRD&nbsp; &nbsp;&nbsp; &nbsp;// Data Direction Register for Command Port
<br />

<br />
#define LCD_DATA_IN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;PINA&nbsp; &nbsp;&nbsp; &nbsp;// Data Input Register
<br />
#define LCD_DATA_OUT&nbsp; &nbsp;&nbsp; &nbsp;PORTA&nbsp; &nbsp;&nbsp; &nbsp;// Data Output Register
<br />
#define LCD_DATA_DIR&nbsp; &nbsp;&nbsp; &nbsp;DDRA&nbsp; &nbsp;&nbsp; &nbsp;// Data Direction Register for Data Port
<br />

<br />
// Command Port Bits
<br />
#define D_I&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x03&nbsp; &nbsp;&nbsp; &nbsp;// D/I Bit Number
<br />
#define R_W&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x04&nbsp; &nbsp;&nbsp; &nbsp;// R/W Bit Number
<br />
#define EN&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x05&nbsp; &nbsp;&nbsp; &nbsp;// EN Bit Number
<br />
#define CSEL1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x06&nbsp; &nbsp;&nbsp; &nbsp;// CS1 Bit Number
<br />
#define CSEL2&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x07&nbsp; &nbsp;&nbsp; &nbsp;// CS2 Bit Number
<br />

<br />
// Chips
<br />
#define CHIP1&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x00
<br />
#define CHIP2&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x01
<br />

<br />
// Commands
<br />
#define LCD_ON&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3F
<br />
#define LCD_OFF&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x3E
<br />
#define LCD_SET_ADD&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x40
<br />
#define LCD_SET_PAGE&nbsp; &nbsp;&nbsp; &nbsp;0xB8
<br />
#define LCD_DISP_START&nbsp; &nbsp;&nbsp; &nbsp;0xC0
<br />

<br />
// Colors
<br />
#define BLACK&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0xFF
<br />
#define WHITE&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0x00
<br />

<br />
// Font Indices
<br />
#define FONT_LENGTH&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;0
<br />
#define FONT_FIXED_WIDTH&nbsp; &nbsp;2
<br />
#define FONT_HEIGHT&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;3
<br />
#define FONT_FIRST_CHAR&nbsp; &nbsp;&nbsp; &nbsp;4
<br />
#define FONT_CHAR_COUNT&nbsp; &nbsp;&nbsp; &nbsp;5
<br />
#define FONT_WIDTH_TABLE&nbsp; &nbsp;6
<br />

<br />

<br />
#define KS0108_SCREEN_WIDTH&nbsp; &nbsp;&nbsp; &nbsp;128
<br />
#define KS0108_SCREEN_HEIGHT&nbsp; &nbsp;64
<br />

<br />
#define KS0108_PAGE_START_x&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;0
<br />
// Page address
<br />
#define KS0108_PAGE_ZERO_Y&nbsp; &nbsp; &nbsp; &nbsp;0
<br />
#define KS0108_PAGE_ONE_Y&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;8
<br />
#define KS0108_PAGE_TWO_Y&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;16
<br />
#define KS0108_PAGE_THREE_Y&nbsp; &nbsp; &nbsp; &nbsp;24
<br />
#define KS0108_PAGE_FOUR_Y&nbsp; &nbsp; &nbsp; &nbsp;32
<br />
#define KS0108_PAGE_FIVE_Y&nbsp; &nbsp; &nbsp; &nbsp;40
<br />
#define KS0108_PAGE_SIX_Y&nbsp; &nbsp; &nbsp;&nbsp; &nbsp;48
<br />
#define KS0108_PAGE_SEVEN_Y&nbsp; &nbsp; &nbsp; &nbsp;56</div>
<br />

<br />
Main file :----
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">#include &lt;inttypes.h&gt;
<br />
#include &lt;avr/io.h&gt;
<br />
#include &lt;avr/pgmspace.h&gt;
<br />
#include &lt;util/delay.h&gt;
<br />

<br />
#include &quot;ks0108.h&quot;
<br />

<br />

<br />
volatile uint16_t i;
<br />

<br />
int main&#40;void&#41; 
<br />
&#123;
<br />

<br />
&nbsp; &nbsp;// Wait a little while the display starts up
<br />
&nbsp; &nbsp;for&#40;i=0; i&lt;15000; i++&#41;;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;// Initialize the LCD
<br />
&nbsp; &nbsp;ks0108Init&#40;0&#41;;&nbsp; &nbsp;
<br />

<br />
&nbsp; &nbsp;//Draw a line from x to y 
<br />
&nbsp; &nbsp;LCD_drawLine&#40;0,0,127,63&#41;;
<br />

<br />
&nbsp; &nbsp;//Give some delay
<br />
&nbsp; &nbsp;for&#40; i=0; i&lt;200; i++&#41;;
<br />
&nbsp; &nbsp;_delay_ms&#40;1000&#41;;
<br />

<br />
&nbsp; &nbsp;//Draw a line from x to y 
<br />
&nbsp; &nbsp;LCD_drawLine&#40;0,63,127,0&#41;;
<br />

<br />
&nbsp; &nbsp;//Give some delay
<br />
&nbsp; &nbsp;for&#40; i=0; i&lt;200; i++&#41;;
<br />
&nbsp; &nbsp;_delay_ms&#40;1000&#41;;
<br />

<br />
&nbsp; &nbsp;//Draw a circle
<br />
&nbsp; &nbsp;LCD_drawCirc&#40;64,32,20,BLACK&#41;;
<br />

<br />
&nbsp; &nbsp;//Give some delay
<br />
&nbsp; &nbsp;for&#40; i=0; i&lt;200; i++&#41;;
<br />
&nbsp; &nbsp;_delay_ms&#40;1000&#41;;
<br />

<br />
&nbsp; &nbsp;//Draw a circle
<br />
&nbsp; &nbsp;LCD_fillCirc&#40;64,32,10&#41;;
<br />

<br />
&nbsp; &nbsp;//Give some delay
<br />
&nbsp; &nbsp;for&#40; i=0; i&lt;200; i++&#41;;
<br />
&nbsp; &nbsp;_delay_ms&#40;1000&#41;;
<br />
&#125;</div><hr />
<b>katochd46</b> - Sep 18, 2010 - 04:29 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical LCD<hr class="sep"/>
any one can suggest on this ?<hr />
<b>bperrybap</b> - Sep 18, 2010 - 08:10 AM<br />
<b>Post subject: </b>Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graphical<hr class="sep"/>
<div class="quotetitle">katochd46 wrote:</div><div class="quotecontent">
<br />
hello bill, i compiled the Sami Varjo library &amp; changed the port as per my req, but none of the function is  working properly.</div>
<br />

<br />
Sami's code as well as Thiele's code has issues.
<br />
Sami's code has some initialization issues around
<br />
reset and busy polling that can keep it from working
<br />
because the reset initialization will hang.
<br />
Also, some displays (like the one I was using) have
<br />
a separate RESET status for each chip.
<br />
Once those are fixed it worked fairly well other than
<br />
a few minor character rendering issues.
<br />

<br />
The most complete and robust code for ks0108 and
<br />
sed 1520 based modules is the Arduino glcd library code,
<br />
which includes many example programs and full API documenation.
<br />
Yeah I know it is Arduino and is C++, and I'm no
<br />
fan of Arduino, but I ended up being part of a glcd
<br />
library project and that is where I put my energies
<br />
over a 9 month period to get a feature rich, easy to use
<br />
library up and working.
<br />
I spent many 100s of hours updating the Arduino glcd library code,
<br />
adding in many features, making the code faster and much more robust,
<br />
and testing on many different AVRs and glcd modules.
<br />

<br />
At this point the newest code is in BETA but is very solid.
<br />

<br />
I am intending to create a real library (Arduino &quot;libraries&quot; are not real libraries)
<br />
that can be built with standard AVR tools without the Arduino IDE - and possibly a library for C code vs C++
<br />
I just haven't gotten around to it.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
But i took the line drawing algo &amp; cirle drawing algo from the sammi library &amp; integrated into Fabian Maximilian Thiele' library it is working. I am able to draw the circle &amp; line as per my will.
<br />

<br />
But when i integrated the cirle fill &amp; clear algo is only working if circle is on the left hand side means on left chip but it is not atall working for right chip, if half my circle is on left chip &amp; other half is on right chip, only left half will be displayed.
<br />
As we know in code circle fill is calling fill line function &amp; fill line function is calling set dot function &amp; it is the function which is writing to LCD.
<br />

<br />
In mt case i am using the ks0108SetDot from the Thiele
<br />
library, as i have integrated the algo in the Thiele library. But this function have been working fine for me so far.
<br />

<br />
</div>
<br />

<br />
But you did make a few changes to the code when you &quot;ported&quot; it.
<br />

<br />
The line drawing routine is incomplete. It only handles vertical and horizontal lines - I don't think that will cause Sami's circle fill routine to fail.
<br />
A true Bresenham function is very compact and simple.
<br />

<br />
My suspicion is that the changes made to the boundary checking in the circle function are what is causing the &quot;problem&quot;.
<br />
I haven't taken the time to
<br />
fully go through Sami's circle code but I'm guessing that while the variables may be &quot;x&quot; and &quot;y&quot; that they may not always be used for those purposes. Circles are symmetric and so you sometimes flop things around. So it may be that the boundary checking is incorrectly failing.
<br />
There are a few reasons that this comes to mind.
<br />
- I know Sami's code did draw full filled circles as I used it for a few months while playing with it.
<br />
- Note that Sami's code compared both x &amp; y values to the display width - while not really correct it is a difference from what you are doing now.
<br />
- Also I noted that in your picture there is a line along the left side of the display which would be x value 0.
<br />

<br />
My guess is that if you turned off the boundary checks, or did it the way Sami did, the code would probably draw the circle correctly.
<br />

<br />
The boundary check method that Sami's does of setting a value to 0 when it is outside of a &quot;valid&quot; range has the unfortunate
<br />
side effect of corrupting coordinates which then corrupts the graphic operation in progress.
<br />

<br />
My code is very different in this area. I allowed lines to be drawn &quot;off the display&quot;. The reason for this is that this allows a line to begin or end off the display and the middle can be on the display. This allow lines or circles to be drawn that are larger than the display and those pixels that are within the display bounds to still be drawn.
<br />
The way to handle this is to not check for bounds in the
<br />
functions like circle but to check down lower in the plotting functions like SetDot() and then throw away pixels that are outside the boundaries.
<br />

<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 18, 2010 - 10:00 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graph<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">My guess is that if you turned off the boundary checks, or did it the way Sami did, the code would probably draw the circle correctly. </div>
<br />
Yes even i did this at my end, commented the boundary check in Bresenham's line algorithm function it is working. It was just an guess.
<br />

<br />
But it is not drawing the line correctly in the 64 column, rest circle is drawn correctly. how to get around this ?
<br />
Please suggest.
<br />

<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The most complete and robust code for ks0108 and 
<br />
sed 1520 based modules is the Arduino glcd library code, </div>
<br />
But i am using c and it is in c++.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">I spent many 100s of hours updating the Arduino glcd library code, 
<br />
adding in many features, making the code faster and much more robust, 
<br />
and testing on many different AVRs and glcd modules. </div>
<br />
Same here, its taking lot of time &amp; energy to make G-LCD lib working.<hr />
<b>katochd46</b> - Sep 18, 2010 - 12:01 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 graph<hr class="sep"/>
bill, i did little modification to circle draw fill algo, instead of using the Bresenham function to draw an line, i used Thiele' library function ks0108DrawVertLine, and its working fine.
<br />

<br />
Also it is very fast because Bresenham function was operating pixel wise writting many pixels repedly. But ks0108DrawVertLine it is not rewriting the same pixel atall &amp; speed is good.
<br />

<br />
But still one 0.1% bug that there is one extra dot comming at 64 line. Can you please suggest why ?
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">//------------------------------------------------------------------------------
<br />
//General circle operation &#40;!NON OPTIMIZED = same pixels drawn multiple times&#41;
<br />
// pLineFun must point to function that draws lines between points
<br />
void _LCD_doCirc&#40;uint8_t x1, uint8_t y1, uint8_t radius,
<br />
&nbsp; &nbsp;&nbsp; &nbsp;uint8_t color&#41;
<br />
&#123;&nbsp; 
<br />
&nbsp; uint8_t&nbsp; y=0, x=0, d = 0;
<br />
&nbsp; int8_t part; 
<br />
&nbsp; d = y1 - x1;
<br />
&nbsp; y = radius;
<br />
&nbsp; part = 3 - 2 * radius;
<br />
&nbsp; while &#40;x &lt;= y&#41; &#123;
<br />
/*&nbsp; pLineFun&#40;x1 + x, y1 + y,x1 + x, y1 - y&#41;;
<br />
&nbsp; &nbsp; pLineFun&#40;x1 - x, y1 + y,x1 - x, y1 - y&#41;;
<br />
&nbsp; &nbsp; pLineFun&#40;&#40;y1 + y - d&#41;, y1 + x,&#40;y1 + y - d&#41;, y1 - x&#41;;
<br />
&nbsp; &nbsp; pLineFun&#40;&#40;y1 - y - d&#41;, y1 + x,&#40;y1 - y - d&#41;, y1 - x&#41;;
<br />
*/
<br />

<br />
/*
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;x1 + x, y1 - y, &#40;&#40;y1 + y&#41; - &#40;y1 - y&#41;&#41;, color&#41;;
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;x1 - x, y1 - y, &#40;&#40;y1 + y&#41; - &#40;y1 - y&#41;&#41;, color&#41;;
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;&#40;y1 + y - d&#41;,&nbsp; y1 - x, &#40;&#40;y1 + x&#41;-&#40; y1 - x&#41;&#41;, color&#41;;
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;&#40;y1 + y - d&#41;,&nbsp; y1 - x, &#40;&#40;y1 + x&#41;-&#40; y1 - x&#41;&#41;, color&#41;;
<br />
*/
<br />

<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;x1 + x, y1 - y, 2*y, color&#41;;
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;x1 - x, y1 - y, 2*y, color&#41;;
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;&#40;y1 + y - d&#41;/*x1 + y*/,&nbsp; y1 - x, 2*x, color&#41;;
<br />
&nbsp; &nbsp;ks0108DrawVertLine&#40;&#40;y1 - y - d&#41;/*x1 - y*/,&nbsp; y1 - x, 2*x, color&#41;;
<br />

<br />
//_delay_ms&#40;1000&#41;;
<br />
&nbsp; &nbsp; if &#40;part &lt; 0&#41; part += &#40;4 * x + 6&#41;;
<br />
&nbsp; &nbsp; else &#123;
<br />
&nbsp; &nbsp; &nbsp; part += &#40;4 * &#40;x - y&#41; + 10&#41;;
<br />
&nbsp; &nbsp; &nbsp; y--;
<br />
&nbsp; &nbsp; &#125;
<br />
&nbsp; &nbsp; x++;
<br />
&nbsp; &#125;
<br />
&nbsp; &nbsp; &nbsp; 
<br />
&#125;</div>
<br />

<br />

<br />
Also i am looking forward to draw an cylinder, for this i need to draw two parallel lines, that is possible.
<br />

<br />
But how to draw an ellipse ? Is there an graphics algorithm which can be used ?
<br />

<br />
can any one please suggest about it.<hr />
<b>bperrybap</b> - Sep 18, 2010 - 06:16 PM<br />
<b>Post subject: </b>Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x64 g<hr class="sep"/>
<div class="quotetitle">katochd46 wrote:</div><div class="quotecontent">bill, i did little modification to circle draw fill algo, instead of using the Bresenham function to draw an line, i used Thiele' library function ks0108DrawVertLine, and its working fine.
<br />

<br />
Also it is very fast because Bresenham function was operating pixel wise writting many pixels repedly. But ks0108DrawVertLine it is not rewriting the same pixel atall &amp; speed is good.</div>
<br />

<br />
There are many optimizations that can be made in the code.
<br />
Thiele's code (Sami's too but not as much) is also very
<br />
inefficient at the low levels. For example, Thiele
<br />
sets columns &amp; addresses on both chips rather than just the needed one.
<br />
Hardware commands are very slow. A better way is to only send the minimal hardware commands necessary.
<br />
To do this means tracking the location of all the chips (can be more than 2 on larger displays) and only sending set column or set address commands when the hardware
<br />
needs to be repositioned and sending nothing if the hardware is already at the proper location.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
But still one 0.1% bug that there is one extra dot comming at 64 line. Can you please suggest why ?
<br />
</div>
<br />

<br />
Don't get me started on all the +1 or -1 pixel errors.
<br />
This is a total mess. Thiele tended to model his
<br />
API after the Java graphics class which uses (IMHO)
<br />
a goofy method of rendering pixels. Summary:
<br />
is it draws pixels &amp; lines between the physical pixels.
<br />
So you end up with 1 pixel more than you ask for when
<br />
drawing lines and rectangles.
<br />
Go have a read about how Java draws its pixels
<br />
and you will see why.
<br />

<br />
Sami's API tends to give you exactly the number
<br />
of pixels you ask for.
<br />

<br />
I say &quot;tends to&quot; because both have inconsistencies.
<br />
For example, Thieles +1 stuff (as well as JAVA)
<br />
only gives you the extra pixel for vertical and
<br />
horizontal lines. For things like curves (on JAVA)
<br />
or things like angled lines the pixel count is exact.
<br />

<br />
Sami's API was much more consistent in this area
<br />
and the Arduino GLCD library has been updated to
<br />
match the JAVA API and the Arduino glcd library
<br />
documentation reflects how all the functions really work. 
<br />

<br />
Bottom line is that there will be difference in the APIs
<br />
with respect to how lines are drawn.
<br />
Ask for a vertical or Horizontal line starting
<br />
at N and 5 pixels long, Thieles line routines draw 6 pixels and Sami's draw 5.
<br />
So if you mix and match higher level routines between the two,
<br />
you will end up with +1 or -1 pixel type errors.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Also i am looking forward to draw an cylinder, for this i need to draw two parallel lines, that is possible.
<br />

<br />
But how to draw an ellipse ? Is there an graphics algorithm which can be used ?
<br />

<br />
can any one please suggest about it.</div>
<br />

<br />
Ellipse is a symmetric figure just like a circle.
<br />
The Bresenham circle algorithm can be tweaked to do ellipses.
<br />

<br />
See this paper:
<br />
<a href="http://homepage.smc.edu/kennedy_john/belipse.pdf" target="_blank" class="postlink">http://homepage.smc.edu/kennedy_john/belipse.pdf</a>
<br />

<br />
Attached is a sample of code that uses that algorithm.
<br />
You will have to tweak it slightly as it was setup for the Arduino glcd library.
<br />

<br />
I added an ifdef so you can see what has to be done to fill the ellipse vs draw an outline.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 19, 2010 - 01:42 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
Hello bill, yes algorithm is working fine &amp; i am able to draw an ecliipse &amp; an cylinder. I am able to draw half ellipse also.
<br />

<br />
Even i am able to remove some bug from my driver because of which image was not comming right at 64 line.
<br />

<br />
Thanks for your support. But i need your further support, then i can move forward toward game making.
<br />

<br />
draw an polygon &amp; fill it.
<br />
draw an curve --- which i can use to draw path(road).
<br />
draw an triangle &amp; fill it.
<br />

<br />
please Can you suggest some algo about this.<hr />
<b>bperrybap</b> - Sep 19, 2010 - 09:09 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
Curve's and Polygon fills are quite complex and potentially require floating point math.
<br />
There are many resources available about polgons and how to fill them if you google around.
<br />

<br />
Even if you trim the algorithms down they can still
<br />
be fairly CPU intensive especially for these small 8 bit AVRs.
<br />

<br />
If your final goal is writing some games, then you might want to consider using bitmaps for the majority of shapes
<br />
especially those that need to be animated.
<br />

<br />
Bitmaps are nice for animations and they can be
<br />
quickly drawn as no run-time calculations needed.
<br />

<br />
The Rocket game included in the Arduino glcd library
<br />
does this. It is very simple but shows how to create
<br />
a simple game using bitmap images.
<br />

<br />
Also for things like a simple race car game or a ski
<br />
game, you can use a bitmap for the figure in the middle of the road and the obstacles in the road
<br />
and horizontal lines that change in size
<br />
to create an effect of a path/road moving back and forth.
<br />

<br />
In order to get the speed up and keep things like flicker down, you will have to do many special techniques.
<br />

<br />
For something that has lots of animation on something like a ks0108, a frame buffer is the best way to go;
<br />
however, this is not the way that the Theile's, Sami's, or the Arduino glcd library works.
<br />

<br />
A frame buffer allows very fast updates of the buffer and then periodically the buffer is flushed out to the physical glcd display.
<br />
If you have enough memory, you can even have multiple
<br />
frame buffers to allow overlays so that things like
<br />
text and graphics can be kept separate in their
<br />
own buffers which are then merged when pushing out to the
<br />
physical glcd display.
<br />

<br />
Have Fun.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 20, 2010 - 04:27 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Even if you trim the algorithms down they can still 
<br />
be fairly CPU intensive especially for these small 8 bit AVRs.</div> 
<br />
thanks for guiding. then i think now i can move ahead to make some game.
<br />

<br />
I will start with very simple game  --- PONG GAME ----
<br />
there will definately some implementation which i can find on net, to get an idea &amp; reference about game.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">a frame buffer is the best way to go; </div>
<br />
Means that make changes in ram &amp; flush the changes in an single go. So here you are saying that i should maintain an 128x64 bit buffer &amp; make changes in that buffer &amp; flash it in an single go, to whole screen.
<br />
Or we can say that divide screen into suppose  16 part. Maintain buffer for each part &amp; change the required buffer when req &amp; flash on the screen at single go.
<br />

<br />
So this will reduce the flickeringn b/w images. 
<br />

<br />
Please suggest is my understanding right or not ?<hr />
<b>bperrybap</b> - Sep 20, 2010 - 09:13 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
For something like a pong game you can use the libraries &quot;as is&quot;.
<br />
No need to change to a frame buffer. Pong has very little animations.
<br />

<br />
If you do decide to do a frame buffer, how you need to flush
<br />
it depends on several factors. If there are lots of changes
<br />
then you will need to flush the entire buffer. If there are just
<br />
a few changes, it might be quicker to flush only a part of the display buffer,
<br />
but at some point the overhead of tracking which part to flush
<br />
can take more time than actually doing the full flush, especially
<br />
if most of the display is needing updating the majority of the time.
<br />
i.e. dumb routines can sometimes be faster than smarter routines.
<br />

<br />
Sequential writes are quite fast. ~1us per byte/page.
<br />
It is the commands and reads that are slow. 
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 20, 2010 - 04:08 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">If there are lots of changes then you will need to flush the entire buffer</div>
<br />

<br />
But the question is how we can create an frame buffer in this case. Suppose i want an tiles bckground for game, so in this case i have to flush the entire 128x64 bit buffer to LCD.
<br />

<br />
Now how can i create an full 128x64 bit frame image well in advance. I found some tool on net which are capable to convert BMP to an array of data.
<br />

<br />
Is there any tool where i can create my own frame manually. by making pixel on an off for KS0108 LCD. 
<br />
And convert it into hex array. In this way i can create an background as per my req.
<br />
And i can easily store this data in FLASH.
<br />

<br />
But manually i cannot achive that accuracy for an frame.
<br />

<br />
Please suggest, what is the right way to procede in this regard ?<hr />
<b>clawson</b> - Sep 20, 2010 - 04:59 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
When using frame buffers (Windows calls them &quot;memory contexts&quot;) you use the same graphics API as you would for direct writes to the display but the lowest level access is modified to write to a RAM buffer rather than transferring bytes over the data channel to the display. In systems where you can tell when the display goes into the vertical back porch (aka Vsync)  you can then synchronise the blit of the frame buffer to the actual display RAM &quot;behind&quot; the frame scan so that no flickering is seen between one frame display and the next. I don;t think KS0108 style displays (because they have on-board frame buffers) have this facility though. So the only advantage of a separate frame buffer is for fast read-back when doing AND and OR blits into the frame buffer.<hr />
<b>JohanEkdahl</b> - Sep 20, 2010 - 06:23 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Windows calls them &quot;memory contexts&quot;
<br />
</div>
<br />
Isn't it &quot;Device Contexts&quot;?<hr />
<b>clawson</b> - Sep 20, 2010 - 08:33 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
Johan,
<br />

<br />
We're both right:
<br />

<br />
<!-- m --><a href="http://msdn.microsoft.com/en-us/library/dd145049(VS.85).aspx" target="_blank">http://msdn.microsoft.com/en-us/library ... S.85).aspx</a><!-- m -->
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Memory Device Contexts</div>
<br />

<br />
(there's also &quot;Printer Device Contexts&quot; so personally I drop the &quot;Device&quot; - YMMV)<hr />
<b>katochd46</b> - Sep 21, 2010 - 04:05 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">In systems where you can tell when the display goes into the vertical back porch (aka Vsync) you can then synchronise the blit of the frame buffer to the actual display RAM &quot;behind&quot; the frame scan so that no flickering is seen between one frame display and the next</div>So here are you taking about T.V, as you have used the term Vsync
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">So the only advantage of a separate frame buffer is for fast read-back when doing AND and OR blits into the frame buffer.</div>
<br />
so i have to maintain an 128x64 bits buffer. write an driver code which modifies ram buffer in the same way as the LCD is being modified. once changes are done flush the buffer. Advantage will be that we can avoid flickring. Is it right ?
<br />
Now i got why &quot;bobgardner&quot; mentioned in his previous post that he use to maintain an buffer an changes data in that. At that time i was confused that why he is using this kind of approch where the memory consumption will increase so much.
<br />

<br />

<br />
But the original question was that how can i create an background for my game, which i know well in advance, example there will be roof &amp; walls &amp; floor with particular tiles. This kind of predefined data we can have in FLASH directly. I found some game like packman where they have kept the backgorund tiles frame directly in prog-mem. So how would they have created this, manually by drawing pixel on an off on paper, or they would have used some s/w tool. In google i did not found some open source tool of this type.
<br />

<br />
Please suggest how should i create an frame with predefined data ? sould i use paper &amp; pen to create an frame or there is some standard tool for this ? 
<br />

<br />
I think in animation industry also they are creating  frame for an image. What is there approach ? Do they draw on paper or use some tool to make image of there req.
<br />
If they will use frame buffer does it not increase the delay for processing time of buffer which can cause flickring b/w frames &amp; for the movie fickring is the worst thing.
<br />

<br />

<br />
Please do clarify these questions ?<hr />
<b>bperrybap</b> - Sep 21, 2010 - 08:09 AM<br />
<b>Post subject: </b>Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD<hr class="sep"/>
<div class="quotetitle">clawson wrote:</div><div class="quotecontent">... you can then synchronise the blit of the frame buffer to the actual display RAM &quot;behind&quot; the frame scan so that no flickering is seen between one frame display and the next.I don;t think KS0108 style displays (because they have on-board frame buffers) have this facility though.</div>
<br />
True. There is no true syncing between the host i/f
<br />
and the on board lcd updates. However, I've noticed
<br />
that doing commands and reads tends to cause a bit more flicker than back to back writes.
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
So the only advantage of a separate frame buffer is for fast read-back when doing AND and OR blits into the frame buffer.</div>
<br />
There are some other things that you can do depending
<br />
on how fancy you get. With multiple frame buffers
<br />
you can have objects on different &quot;planes&quot; so that
<br />
things like text can scroll on top of the graphics.
<br />

<br />
Another advantage of a frame buffer is that any context
<br />
can update the buffer. i.e. foreground or interrupt
<br />
contexts can both update the buffer with some
<br />
very simple synchronization.
<br />

<br />
When not using a frame buffer, everything must be
<br />
single threaded and typically must be done at
<br />
foreground context because the low level i/o code
<br />
can't really be re-entrant and you can't really mask
<br />
interrupts during the full i/o operation because
<br />
that can sometimes be several milliseconds.
<br />
(I guess you could do it, if you can tolerate the
<br />
long interrupt latencies)
<br />

<br />
I intentionally avoided using a frame buffer because I wanted the code to be able to run on the smaller AVRs like a m168 and support any sized display up to 256x256 pixels (larger if the 8 bit coordinates are converted to 16 bit values).
<br />
This would simply not be possible using a frame buffer
<br />
as there simply is not enough RAM for the buffer.
<br />

<br />
There is also a &quot;hybrid&quot; mode that can be done
<br />
that uses a buffer as a write-through cache.
<br />
I've experimented with this and it is quite effective.
<br />
In this mode you write to both the buffer and the physical display but only read from the buffer.
<br />
This code didn't make it into the current Arduino glcd library beta, but may get tossed into a future release.
<br />
The issue comes down to RAM. There simply is not enough
<br />
to operate with a buffer on the smaller AVRs or the
<br />
larger glcd displays.
<br />

<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Please suggest how should i create an frame with predefined data ? sould i use paper &amp; pen to create an frame or there is some standard tool for this ? </div>
<br />
The Arduino glcd library also includes a java based utility tool to convert a standard windows .bmp format file into a .h file that can be included in your code.
<br />
Then you simply call the bitmap function to draw it on the display.
<br />
(like I said the Arduino glcd library is the most complete glcd library package I've seen at this point).
<br />

<br />
However, Sami Varjo also wrote a open source GPL commandline bitmap to glcd header file tool as well.
<br />
Here is the link to that tool:
<br />
<a href="http://sourceforge.net/projects/bmp2glcd/" target="_blank" class="postlink">http://sourceforge.net/projects/bmp2glcd/</a>
<br />
I can attest for the tool working as I've used it to create many bitmaps that I used with Sami's glcd library 
<br />
when I was playing with it.
<br />
Later I created a tweaked version of the tool for use
<br />
with the Arduino GLCD library.
<br />

<br />
I had to tweak it (actually added a command line option), because the Arduino glcd library stores the bitmap data in a slightly different format.
<br />
The Arduino glcd library includes the bitmap dimensions
<br />
in the bitmap data.
<br />

<br />
The arduino glcd library HTML documenation has links off to many resources for fonts and font tools as well.
<br />
The library package also includes a java based font tool
<br />
that can convert system fonts to header files for use with the library.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 21, 2010 - 08:19 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
ImageJ :--
<br />
I found one tool which can be used to create an bmp image of required size &amp; alter it as per req. So the image created, we can convert bmp to character array using the fastlcd programe mentioned in this link.
<br />
<a href="http://www.scienceprog.com/controlling-graphical-128x64-lcd-based-on-ks0108/" target="_blank" class="postlink">http://www.scienceprog.com/controlling-graphical-128x64-lcd-based-on-ks0108/</a>
<br />

<br />
ImageJ :--
<br />
<a href="http://rsbweb.nih.gov/ij/index.html" target="_blank" class="postlink">http://rsbweb.nih.gov/ij/index.html</a>
<br />
<a href="http://rsbweb.nih.gov/ij/docs/menus/file.html" target="_blank" class="postlink">http://rsbweb.nih.gov/ij/docs/menus/file.html</a>
<br />
<a href="http://en.wikipedia.org/wiki/ImageJ" target="_blank" class="postlink">http://en.wikipedia.org/wiki/ImageJ</a>
<br />
<a href="http://rsbweb.nih.gov/ij/docs/pdfs/ImageJ.pdf" target="_blank" class="postlink">http://rsbweb.nih.gov/ij/docs/pdfs/ImageJ.pdf</a>
<br />

<br />
Also mentioned in the pdf :--
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Note that the status bar, below the
<br />
tool bar, gives information such as the coordinates (xx, yy) of the selection on the frame.</div>
<br />
Is this approach right ?
<br />

<br />

<br />

<br />
But i am not able to find an tool which can show the whole 128x64 pixels &amp; we can select the req pixel. As letter 'F' have been selected in the attached picture.
<br />
And at last we can convert it into an character array.
<br />

<br />
have any body used tool like this, then please suggest ?<hr />
<b>katochd46</b> - Sep 21, 2010 - 08:53 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
As mentioned in aurduino doc :--
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">You can also display your own images in your sketch.</div>
<br />
Yes aurdino font creater is same as GLCDFontCreator2 java program where you can fetch fonts from Windows system and generate fonts for graphical LCD.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">tool which can show the whole 128x64 pixels &amp; convert it into array </div>
<br />
But if some thing like above is possible then it will be great, because we can create full frame. I do not know java otherwise i would have created something like this.<hr />
<b>clawson</b> - Sep 21, 2010 - 11:20 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
I presume you have read this page:
<br />

<br />
<!-- m --><a href="http://www.scienceprog.com/controlling-graphical-128x64-lcd-based-on-ks0108/" target="_blank">http://www.scienceprog.com/controlling- ... on-ks0108/</a><!-- m -->
<br />

<br />
and downloaded the tools such as &quot;fastlcd&quot; that it links to?
<br />

<br />
As for Vsync. What makes you think that is a TV only concept? At the &quot;raw&quot; level all LCD graphic panels have Hsync, Vsync and pixel clock. A 128x64 mono panel for example, will likely be refreshed something like once every 1/20s (perhaps quicker) so there's a frame (V) sync pulse at 20Hz. Assume it's a single controller and not the two 64x64 controllers we actually know it is and there's 64 lines per frame so there's an Hsync pulse running at 64 times the Vsync. That is 1280Hz. Along each line that is scanned there are 128 pixels so the Pixel clock is 128 times the Hsync. That is 1280Hz*128 = 163,840Hz
<br />

<br />
All (graphic) LCDs have these same signals. In fact it's a bit more complicated in that there may be additional delay both before and after the horizontal scan lines (known as the horizontal front porch and horizontal back porch) and there's also likely a delay before and after the entire frame scan (known as the vertical front porch and vertical back porch).
<br />

<br />
Luckily, when you use an &quot;intelligent&quot; controller like the KS0108 (with KS0107) it hides all this detail from you. The downside is that you don't know where frame sync (start of vertical front porch) occurs to allow for frame update synchronisation.<hr />
<b>katochd46</b> - Sep 21, 2010 - 01:49 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">As for Vsync. What makes you think that is a TV only concept? At the &quot;raw&quot; level all LCD graphic panels have Hsync, Vsync and pixel clock. A 128x64 mono panel for example, will likely be refreshed something like once every 1/20s (perhaps quicker) so there's a frame (V) sync pulse at 20Hz. Assume it's a single controller and not the two 64x64 controllers we actually know it is and there's 64 lines per frame so there's an Hsync pulse running at 64 times the Vsync. That is 1280Hz. Along each line that is scanned there are 128 pixels so the Pixel clock is 128 times the Hsync. That is 1280Hz*128 = 163,840Hz. </div>
<br />
So as per this explanation Vsync clock will start the frame update, Hsync clock will start the line update, pixel clock will start the pixel update.
<br />

<br />
Is it right ?
<br />

<br />
So are these pulses used to scan page or update page ?
<br />

<br />

<br />
Also the question is when the controller will feel that it is the time to start the Vsync or Hsync or Pixel clock ?
<br />

<br />
In the case of LCD it is an slave to Atmel microcontroller &amp; serving its request. So request is command or i am writing or reading data. I think when command is send then there is no need for these clocks but when writing or reading then we need these pulses ?
<br />

<br />
And if i am only writing or reading one byte of data then also full frame is updated or scanned.
<br />

<br />
So does some LCD have full RAM buffer for the LCD pixels ?
<br />
In KS0108B datasheet i did not found that they have mentioned about the buffer.
<br />

<br />

<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">The downside is that you don't know where frame sync (start of vertical front porch) occurs to allow for frame update synchronisation</div>So what will be the advantage for an microcontroller if it knowns where the frame syc is. At present i am not taking care about frame sync, but still my req is processed by KS108 controller.
<br />

<br />

<br />
Cliff can you please clarify it a bit more.<hr />
<b>clawson</b> - Sep 21, 2010 - 02:07 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
So as per this explanation Vsync clock will start the frame update, Hsync clock will start the line update, pixel clock will start the pixel update.
<br />
</div>
<br />
A minute or two with Google image search produces this diagram which shows the relation between Vsync, Hsync and Pixel Clock (XSCL in this case):
<br />

<br />
<img src="http://blog.savel.org/stuff/20080223a.gif" border="0" />
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Also the question is when the controller will feel that it is the time to start the Vsync or Hsync or Pixel clock ?
<br />
</div>
<br />
LCD panel controllers are nothing more than an advanced, cascaded timer and DMA generator. There's no question about when the Vsync or Hsync occur within the cycle of the Pixel Clock (as you can see in that diagram). It's cast in silicon. Or rather it's cast in PROGRAMMABLE silicon - most LCD panel controllers have a set of config registers to define exactly where in the cycle the various pulses occur. For a pretty simple example see chapter 10 in the LH77790A datasheet - that's an ARM7 microcontroller that includes a built in LCD panel controller:
<br />

<br />
<!-- w --><a href="http://www.rockabilly.net/files/chip-manuals/Sharp-LH77790B.pdf" target="_blank">www.rockabilly.net/files/chip-manuals/S ... 77790B.pdf</a><!-- w -->
<br />

<br />
We used it in this:
<br />

<br />
<img src="http://www.amstrad.com/assets/img/emp_pop.jpg" border="0" />
<br />

<br />
But don't get confused between a &quot;raw&quot; LCD panel and the cosseted world of KS0108. The KS0108 is handling all this complexity so you don't have to.<hr />
<b>bperrybap</b> - Sep 21, 2010 - 10:30 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
There is no need for such a glcd frame data editor tool.
<br />
(It can be done using other existing tools)
<br />
That is probably why there hasn't
<br />
been much demand for one and nobody bothered to do one.
<br />
Actually, I did see one or two long ago, but I forgot where.
<br />
You might check out over on the LCD hype forums:
<br />
<a href="http://lcdhype.condense.de" target="_blank" class="postlink">http://lcdhype.condense.de</a>
<br />
But once you have a tool that can convert a standard .bmp bitmap
<br />
file to a GLCD header file,
<br />
you can use other bitmap tools which have many capabilities.
<br />

<br />
On windows, you can even use Microsoft's wimpy paint program to create a 128x64 bitmap and draw anything you like. (It actually works very well for this)
<br />
Then use bmp2glcd or the java bitmap conversion app supplied by the Arduino glcd library
<br />
to connvert the .bmp file to the .h file that defines the glcd data.
<br />

<br />
Any number of bitmap tools can be used to create the bitmap file depending on what you like and your OS.
<br />

<br />
Using this method, you can even convert existing bitmaps or icons that you can find all over the web for
<br />
free into glcd data files.
<br />

<br />
I've even hand drawn images on paper, 
<br />
scanned them in and reduced them down to
<br />
create glcd images.
<br />

<br />
Converting bitmaps into glcd headers is a much more flexible and powerful way to get the glcd data than having to use a GUI program that is customized for 
<br />
drawing/creating glcd header files.
<br />

<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 23, 2010 - 01:28 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">For a pretty simple example see chapter 10 in the LH77790A datasheet - that's an ARM7 microcontroller that includes a built in LCD panel controller: </div><div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">Actually, I did see one or two long ago, but I forgot where. 
<br />
You might check out over on the LCD hype forums: 
<br />
On windows, you can even use Microsoft's wimpy paint program to create a 128x64 bitmap and draw anything you like.
<br />
</div>thanks for the info, I will go through them afterwards.
<br />

<br />

<br />
Related to PONG game is this approch right :--
<br />

<br />

<br />
I am not using frame buffer approach as there is not much need of animation.
<br />

<br />

<br />
I am using four button two for left paddle &amp; two for the right paddle
<br />
for up and down movement.
<br />

<br />
TIMER0 -- used in overflow mode --- same clock as CPU  -- i.e 8mhz
<br />
TIMER1 -- used in CTC mode ---  clock as clk/8
<br />

<br />
I have kept the interupt routine very small.
<br />
so i just want to ask that should i do clear interupt before
<br />
processing the required interupt request.
<br />

<br />
Or this approach is right.
<br />

<br />
cli();
<br />
for example :----
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">&nbsp; &nbsp;for&#40;;;&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;interupt ==1&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; cli&#40;&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// Draw the paddle and ball images as per there relevant position
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;interupt = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;interupt == 2&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; cli&#40;&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// trace the position of ball as per s/w routine &amp; position of paddle
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as per button pressed
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;interupt = 0;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&#125;</div>
<br />

<br />

<br />
present implementation i am not using cli() :---
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">/* output to LCD -- current position of ball &amp; paddle*/
<br />
ISR&#40;TIMER0_OVF_vect&#41; 
<br />
&#123;
<br />
&nbsp; &nbsp;interupt = 1;
<br />
&#125;
<br />

<br />
/* calculation related to Movement of ball &amp; switch pressed for paddle movement */
<br />
ISR&#40;TIMER1_COMPA_vect&#41; 
<br />
&#123;
<br />
&nbsp; &nbsp;interupt = 2;
<br />
&#125;
<br />

<br />
void main_pong&#40;void&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;// Initialise the timer &amp; start them
<br />
&nbsp; &nbsp;ioinit&#40;&#41;;
<br />

<br />
&nbsp; &nbsp;for&#40;;;&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;interupt ==1&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// Draw the paddle and ball images as per there relevant position
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;interupt = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;interupt == 2&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// trace the position of ball as per s/w routine &amp; position of paddle
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; as per button pressed
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;interupt = 0;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&#125;
<br />

<br />
&#125;</div>
<br />

<br />

<br />
Please suggest what to do ?<hr />
<b>bobgardner</b> - Sep 23, 2010 - 01:43 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD 128x<hr class="sep"/>
Lets assume we have a file xyz.bmp. I have a bmp to graphic lcd frame buffer format utility. What is the logical filename and extension for the resulting output file? I suggest xyzbmp.c. It certainly isn't an h file. It generates data in the flash rom. h files are for definitions, macros, structs, and usually dont generate code, because then you can't include them a second time. The whole idea of a header file is to read in the definitions in every file that needs them.<hr />
<b>bperrybap</b> - Sep 23, 2010 - 05:52 PM<br />
<b>Post subject: </b>Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: JHD <hr class="sep"/>
<div class="quotetitle">bobgardner wrote:</div><div class="quotecontent">Lets assume we have a file xyz.bmp. I have a bmp to graphic lcd frame buffer format utility. What is the logical filename and extension for the resulting output file? I suggest xyzbmp.c. It certainly isn't an h file. It generates data in the flash rom. h files are for definitions, macros, structs, and usually dont generate code, because then you can't include them a second time. The whole idea of a header file is to read in the definitions in every file that needs them.</div>
<br />

<br />
Not that I don't agree with you but you are too late.
<br />
Several of the existing tools currently generate .h files.
<br />

<br />
Yeah, I know its an easy fix to the code to create
<br />
a .c instead, but not all tools come with their source.
<br />

<br />
And as you know there are many .h files supplied
<br />
by the AVR libC library that are really code.
<br />

<br />
But I totally do agree with you that creating a .h file
<br />
for data files sucks.
<br />
It creates some really nasty issues like
<br />
if the data was declared static, you end up with multiple
<br />
instances of the data since it gets privately declared by each module that includes the header.
<br />
And if the data is not declared static, you can end up
<br />
with link errors do to multiple declarations.
<br />

<br />
.h files for the data is only &quot;working&quot; because many programmers these days (especially Arduino users) tend
<br />
to use only a single source code module.
<br />

<br />
I think that the ideal situation is that it should 
<br />
generate both, a .h and a .c file.
<br />
The .c file would contain the data and would
<br />
be included in your makefile sources
<br />
and the .h would be included by your code or
<br />
a master .h header file like &quot;bitmaps.h&quot; for the external references to data generated in the .c file(s).
<br />

<br />
I've seen a couple of tools that do this, but it is
<br />
definitely not the norm.
<br />

<br />
If it were me, I'd create only the .c files then
<br />
have a rule in the makefile to automagically generate master .h files
<br />
from all the .c font and bitmap files so that the source code modules would simply include something like &quot;bitmaps.h&quot; or &quot;fonts.h&quot;.
<br />
That way which fonts or bitmaps are included is
<br />
under control of the Makefile.
<br />

<br />
But then I'm a big makefile user and detest IDEs
<br />
for building code because I can't do things like that.
<br />

<br />
Now if you are using the fancy new linker options
<br />
available that removes unreferenced elements, you can create master .h header
<br />
files with the external declarations for ALL the fonts and Bitmaps and then include all the
<br />
.c files in your build and the linker will
<br />
throw out the data elements for the fonts and bitmaps that are not referenced.
<br />

<br />
--- bill<hr />
<b>katochd46</b> - Sep 24, 2010 - 12:38 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: <hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">For a pretty simple example see chapter 10 in the LH77790A datasheet - that's an ARM7 microcontroller that includes a built in LCD panel controller: </div>Cliff,Your project seems to be very complex. Were you using LINUX ?
<br />

<br />
 this means we can write driver for this lcd pannel controller to work with --- lcd without controller.
<br />

<br />
So i think in this case LCD without controller are cheap ?
<br />

<br />
Can you suggest which are the most commonly used LCD without controller? Which one you used in your project ?
<br />

<br />
So this means that the CPU moniter(VGA) which we are using, that to is LCD without controller &amp; is operated by CPU using GRAPICS CARD on our mother board.<hr />
<b>clawson</b> - Sep 24, 2010 - 01:13 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Cliff,Your project seems to be very complex. Were you using LINUX ?
<br />
</div>
<br />
Not in that simple version. We had a co-operative OS we wrote ourselves which followed the WIN16 (not WIN32!) model whereby any of the 80+ tasks are scheduled when they receive messages addressed to them from a central message queue. Each task was implemented as a state machine so that it would never execute more than 5ms at any one time without yielding (and posting itself a message to the queue to say it needs to schedule further states in the state machine.
<br />

<br />
Later on we added video calling to the phone:
<br />

<br />
<img src="http://www.amstrad.com/assets/img/e3_product_enlarge.jpg" border="0" />
<br />

<br />
In this version we moved from the 50MHz Sharp LH77790A which is an ARM7TDMI to the TI OMAP 5910 which is a dual chip silicon having a 150MHz ARM9 and a 150MHz C55xx DSP. Because of the added complexity of doing video encode/decode, audio encode/decode, echo cancellation and all the other things involved in video calling this used the DSP to do the &quot;heavy&quot; work and on the ARM9 (because it has an MMU) we ran Montavista Linux 2.4.18. The rest of the application (several MB of ARM binary) was ported to run as single task in the Linux app space but because it was littered with direct h/w access we had to move all that into either direct kernel modifications (I wrote the LCD driver) or into modprobe'd kernel modules then the app, wherever it previously did direct h/w access generally did IOCTLs to the kernel driver code to achieve the same, though some things lent themselves to block device usage.
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
this means we can write driver for this lcd pannel controller to work with --- lcd without controller. 
<br />
</div>
<br />
Being able to control those LCDs had nothing to do with whether Linux was being used or not. In both cases (in fact there was a third model that preceded these two as well) the key thing was to pick silicon with an embedded LCD panel timing generator. Both the Sharp LH77790A/B (see previous link) and the TI OMAP 5910 have such an LCD DMA controller on board. As I've said previously you dedicate a frame buffer in processor accessible (S)DRAM for the display. You then set the timing generator for the right frame/line syncs, pixel clocks and horiz/vertical front/back porches and point the DMA address base to the frame buffer. You switch on the DMA and then everything happens automatically with the DMA engine in the CPU not only clocking out the data bytes at the right time in the frame scan sequence but also generating the hsyc/vsync and pixel clock pulses as and when they are required. It also handles the generation of the M signal which applies a periodic AC bias to the LCD so that with a static image the crystals do not &quot;burn&quot; a fixed image into the panel (it took me months and several dead panels to get that one right on the colour panel!!)<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
So i think in this case LCD without controller are cheap ?
<br />
</div>
<br />
While it's possible to buy the glass (you generally pay per square inch) separately together with row/column drives (often COG - chip on glass) we actually paid famous LCD panel makers like Densitron to make up a &quot;module&quot; for us which included the glass, row/col drivers, connectors, metal frame, LCD backlight inverter circuit, etc. I forget the prices (this was 10+..5 years ago) but I think we paid something like $30 for a 16 grey scale 480x320 module and $80+ for the 4096 colour 480x320 version. The LCD module was &gt;30% of the BOM cost for both devices. In both cases the screen is something like 6&quot; diagonal (about 3.2&quot; by 4.8&quot;, about 15sq&quot;).
<br />

<br />
Driving panels directly like this is NOT for the feint-hearted. It takes a LOT of engineering to get it right and for home microcontroller use I'd never suggest anyone attempt it.
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Can you suggest which are the most commonly used LCD without controller? Which one you used in your project ?
<br />
</div>
<br />
As I say you don't generally by these things as a pre-made item. You have someone like Densitron build one to order for your design. I think the NRE is something like $200,000 so you have to be ready to buy a LOT panels to make it worthwhile. We made more than 250,000 units of each model so the NRE was amortised at about $1 per unit in addition to the $30/$80 per unit module cost.
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
So this means that the CPU moniter(VGA) which we are using, that to is LCD without controller &amp; is operated by CPU using GRAPICS CARD on our mother board.
<br />
</div>
<br />
There is no &quot;graphics card&quot; as such. While you can get standalone LCD panel timing generators the fact is that you want the display RAM to be writeable by the host CPU to actually put something on the display at the same time that the display timer generation DMA is reading the same RAM to clock out the displayed image. In a single piece of silicon like LH77790A or OMAP5910 the interleaving of DRAM accesses between the DMA and the CPU can be done easily by the silicon designer. To do it with a separate controller then either the controller itself needs to hold its own DRAM frame buffer (exactly as you see with KS0108) or you'd need to use dual port RAM that was readable/writeable by both host CPU and LCD controller at the same time.
<br />

<br />
Interestingly the graphics in IBM PCs have until recently generally contained their own DRAM for frame buffer use but in the latest Intel Atom's a GMA3150 has been integrated into the Intel Atom N425/N450 processor so that it truly can share the CPU's own DRAM without contention issues. So they are actually headed in the same direction as chips like LH77790/OMPA5910/DragonBall and all the other &quot;PDA processors&quot; which integrate an LCD controller and a CPU principally for use in handheld PDAs (though we used them in those non-portable desktop phones)
<br />

<br />
Cliff
<br />

<br />
PS If interested £0.99 may buy you these:
<br />

<br />
<!-- m --><a href="http://cgi.ebay.co.uk/Amstrad-E-mailer-plus-E3-video-phone-software-faulty-/170544351773?pt=UK_MobilePhones_HomePhones_HomePhones_JN&amp;hash=item27b53c4a1d" target="_blank">http://cgi.ebay.co.uk/Amstrad-E-mailer- ... 27b53c4a1d</a><!-- m -->
<br />

<br />
It says they have &quot;software faults&quot; (in MY software? I don't think so!) but they could be broken for spares.<hr />
<b>katochd46</b> - Sep 24, 2010 - 01:57 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
very complex, i have to give some time to understand this concept.
<br />

<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">As I've said previously you dedicate a frame buffer in processor accessible (S)DRAM for the display. You then set the timing generator for the right frame/line syncs, pixel clocks and horiz/vertical front/back porches and point the DMA address base to the frame buffer. You switch on the DMA and then everything happens automatically </div>
<br />
here you are saying with this type of controllers ---- dedicate a frame buffer in processor accessible (S)DRAM for the display -----
<br />
Means i creat 1Kyte buffer array &amp; use the base address of the array as an pointer to DMA location for LCD . 
<br />
Or you want to say that with such big processor seprate block of ram is reserved for each pheripheral devices like LCD,SPI,I2C.
<br />

<br />
Is this DMA an seprate pheripheral device like CPU? as it is capable to make decision how to transfer the data ?
<br />

<br />
Please clarify ?<hr />
<b>clawson</b> - Sep 24, 2010 - 03:04 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
here you are saying with this type of controllers ---- dedicate a frame buffer in processor accessible (S)DRAM for the display ----- 
<br />
Means i creat 1Kyte buffer array &amp; use the base address of the array as an pointer to DMA location for LCD . 
<br />
</div>
<br />
Well take that 480x320 panel. The controller drives it in 12 bit color modes. That is 4:4:4. So for each pixel 2 bytes are used with 4 bits wasted. As such it requires a frame buffer in DRAM that is 480x320x2=307,200 bytes long. Your 1K guess was out a bit - it's really 296K. Our design had something like 32MB of DRAM (as we decompressed the 12MB of code from NAND flash into RAM and ran it there). I annot remember the memory map right now but lets say that the 32MB were mapped to ARM address 0x00000000 thenit spanned to 0x01FFFFFF. I can't remember where I chose to put it but I think I had the LCD buffer on a 1MB boundary so it was maybe at something like the 12MB mark. So I would have programmed 0x00C00000 as the base address of the DMA into the LCD controller. Having told it the colour depth and X/Y dimensions it would know that 307200 bytes would be used so it would be performing the DMA between 0x00C00000 and 0x00C4AFFF
<br />

<br />
As we had the frame rate set at 15fps (I think it was) then the controller had to scan those 307,200 bytes out to the panel 15 times every second. So it was transferring 307,200 * 15 = 4,608,000 bytes per second. So that would have been the speed of the pixel clock. The Vsync was 15Hz (for 15fps) and because there were 320 lines to the display the Hsync would have been running at 320*15 = 4.8kHz
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Or you want to say that with such big processor seprate block of ram is reserved for each pheripheral devices like LCD,SPI,I2C.
<br />
</div>
<br />
No things like SPI and I2C use no RAM - just as on an AVR8. They are remarkably similar on ARM chips to AVR in fact. But as I say the LCD *does* need RAM in our case that was 296K of the DRAM attached to the processor. Unlike AVRs SoC processors like the OMAP5910 don't usually have SRAM on the same chip of silicon. You normally design a circuit with separate DRAM or SDRAM (as in this case) and this is on an external bus to the processor (though it does contain an (S)DRAM refresh controller). The OMAP5910 is a little unusual (mainly because it has the two CPUs that use RAM to communicate) in that it has something like 180K of SRAM built into the chip. When I first read the spec I thought &quot;great we'll put the LCD bufer there&quot;. Then I calculated the size we needed and realised that 296K into 180K does not go. If we'd had a 4 bit grey screen like the previous model it had a 76K frame buffer and would have fitted - but this is why I ended up putting it outside somewhere in the 32MB.
<br />
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
Is this DMA an seprate pheripheral device like CPU? as it is capable to make decision how to transfer the data ?
<br />
</div>
<br />
You've never heard of Direct Memory Access? You may want to explore the Xmega datasheets to see a simple implementation. Basically it's just an address clock. You define a source address and a destination address and a length then say &quot;go&quot; and while the CPU gets on with other things the DMA engine reads from the source and writes to the destination until length transfers have been performed at which point it might either reset the src/dst pointers and start again or it could just stop. If the src or dest are RAM pointers you can ask it to auto increment/decrement after each access. But you can, for example, set it up with a RAM buffer+increment as the source an the UART (say) as the destination and then it will silently clock bytes out to the UART. In this example you would want it to actually wait each time until the UART was ready for the next byte. You could set it so that both src and dest were in RAM then it would just do the equivalent of C's memmove() but without using any CPU time to do it. (Oh you can usually ask for an interrupt when the transfer has finished as your PC does when it's reading/writing sectors to a hard drive). In the case of the LCD controller it's a slightly special form of DMA in that there's that source pointer (0x00C00000 in my example) that will auto-increment but in my case I was running the DMA 16bit wide so each fetch was 16bits wide - to write all 307,200 bytes therefore only took 153,600 transfers, the destination was the single port connected to the LCD panels data lines and the LCD controller not only did the data DMA but pulsed PClk, Vsync, Hsync, M at the relevant moments.
<br />

<br />
Cliff
<br />

<br />
PS I wouldn't get too bogged down in all this - it has nothing to do with programming 8 bit AVRs. From time to time we get someone here saying they want to attach a &quot;raw&quot; 480x320 (often much bigger) LCD panel to an AVR8 but this is not technically possible if for no other reasons than the AVR8 cannot handle hundreds of kilobytes of frame buffer RAM. 128x64 or perhaps 128x128 in mono would be about the limit for most AVRs though with an &quot;intelligent&quot; controller like the KS0108 and it's own RAM obviously larger displays can be attached - but not &quot;raw&quot; and driven by an LCD timing controller. It's the same reason when an AVR8 is driving an analogue VGA video output it cannot get to resolutions much beyond a couple of hundred in either direction as the same limits (RAM and CPU bandwidth) apply for what's effectively the same thing.<hr />
<b>katochd46</b> - Sep 25, 2010 - 09:36 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
Thanks for this valuable explanation, you have having very good command in embedded. May be i will try this when i will move to 32-bit controller.
<br />

<br />
At preset i have completed pong game, the logic is working as per expectation.
<br />
I am using 4 buttons for up-down movement of two paddles.
<br />
S/w option for Ball velocity are:--
<br />
x=2,y=0
<br />
x=2,y=-2
<br />
x=2,y= 2
<br />

<br />
x=-2,y=0
<br />
x=-2,y=-2
<br />
x=-2,y= 2
<br />

<br />

<br />
But i facing problem with syncronisation of two task.
<br />
One task use to update position of the ball &amp; paddle. While other task puts data to LCD for ball &amp; psddle position.
<br />

<br />
I am using two timer 
<br />
16 bit --- used in CTC --- top value 1000 -- freq clk/8
<br />
8 bit --- used in CTC --- overflow mode -- freq clk
<br />

<br />
When 16 bit timer interupt occurs i used to update the local variables related to the position of the ball as per s/w logic &amp; position of the PADDLE,s as per button pressed. 
<br />

<br />
When 8-bit timer overflows i use to send data to LCD for position of ball &amp; paddle.
<br />

<br />
Logic is working OK &amp; i am able to play the game. But many time i use to press button but paddle does not move &amp; sometimes every thing stop moving on LCD, may be overflow of timer's &amp; execution of task does not match.
<br />

<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">/* Movement */
<br />
void timer_movement&#40;unsigned char portB&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;unsigned char p1_up; /* Player 1&nbsp; up&nbsp; button pressed */
<br />
&nbsp; &nbsp;unsigned char p1_dn; /* Player 1 down button pressed */
<br />
&nbsp; &nbsp;unsigned char p2_up; /* Player 2&nbsp; up&nbsp; button pressed */
<br />
&nbsp; &nbsp;unsigned char p2_dn; /* Player 2 down button pressed */
<br />
&nbsp; &nbsp;char pos;
<br />
&nbsp; &nbsp;char loose;
<br />
&nbsp; &nbsp;char paddle_bounce;
<br />
&nbsp; &nbsp;int i;
<br />
&nbsp; &nbsp;int j;
<br />

<br />
&nbsp; &nbsp;/* Read buttons */
<br />
&nbsp; &nbsp;p1_up = portB &amp; 0x04; /* Pin B2 */&nbsp; // left up
<br />
&nbsp; &nbsp;p1_dn = portB &amp; 0x08; /* Pin B3 */&nbsp; // left down
<br />
&nbsp; &nbsp;p2_up = portB &amp; 0x01; /* Pin B0 */&nbsp; // right up
<br />
&nbsp; &nbsp;p2_dn = portB &amp; 0x02; /* Pin B1 */&nbsp; // right down
<br />

<br />
&nbsp; &nbsp;/* Stop paddle movement at wall */
<br />
&nbsp; &nbsp;// p1_pos &amp; p2_pos --- are paddle lower base position
<br />
&nbsp; &nbsp;p1_up = &#40;p1_up &amp;&amp; &#40;p1_pos &gt;= &#40;UPPER_WALL + BASE_OFFSET&#41;&#41;&#41;; // greater than ---- UPPER_WALL=7 actual is 8&nbsp; &nbsp;--- so lower base of paddle -- &#40;UPPER_WALL + PADDLE_HEIGHT&#40;6&#41; = 13&#41;
<br />
&nbsp; &nbsp;p1_dn = &#40;p1_dn &amp;&amp; &#40;p1_pos &lt;= &#40;LOWER_WALL &#41;&#41;&#41;; // less than ---- LOWER_WALL =55 -- actual is at 56 --- so upper base of paddle -- &#40;LOWER_WALL - PADDLE_HEIGHT&#40;6&#41; = 50&#41;
<br />
&nbsp; &nbsp;p2_up = &#40;p2_up &amp;&amp; &#40;p2_pos &gt;= &#40;UPPER_WALL + BASE_OFFSET&#41;&#41;&#41;; // greater than ---- UPPER_WALL=7 actual is 8 --- so lower base of paddle -- &#40;UPPER_WALL + PADDLE_HEIGHT&#40;6&#41; = 13&#41;
<br />
&nbsp; &nbsp;p2_dn = &#40;p2_dn &amp;&amp; &#40;p2_pos &lt;= &#40;LOWER_WALL &#41;&#41;&#41;; // less than ---- LOWER_WALL =55 -- actual is at 56 --- so upper base of paddle -- &#40;LOWER_WALL - PADDLE_HEIGHT&#40;6&#41; = 50&#41;
<br />

<br />
&nbsp; &nbsp;/* Move paddles */
<br />
&nbsp; &nbsp;//if&#40;&#40;p1_up&#41;||&#40;p1_dn&#41;||&#40;p2_up&#41;||&#40;p2_dn&#41;&#41;
<br />
&nbsp; &nbsp;//&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;p1_up&#41; &#123;p1_previous_pos = p1_pos;flag_1 = 1; p1_pos -= DEC_POS;&#125; // dec by 2 --- p1_pos -= DEC_POS;&nbsp; --- DEC_POS = 2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;p1_dn&#41; &#123;p1_previous_pos = p1_pos;flag_1 = 1; p1_pos += INC_POS;&#125; // inc by 2 --- p1_pos += INC_POS;&nbsp; --- INC_POS = 2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;p2_up&#41; &#123;p2_previous_pos = p2_pos;flag_2 = 1; p2_pos -= DEC_POS;&#125; // dec by 2 --- p2_pos -= DEC_POS;&nbsp; --- DEC_POS = 2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;p2_dn&#41; &#123;p2_previous_pos = p2_pos;flag_2 = 1; p2_pos += INC_POS;&#125; // inc by 2 --- p2_pos += INC_POS;&nbsp; --- INC_POS = 2
<br />
&nbsp; &nbsp;//&#125;
<br />
&nbsp; &nbsp;//else
<br />

<br />
&nbsp; &nbsp;/* Move ball only every two clock tick */
<br />
&nbsp; &nbsp;if &#40;&#40;ballClock = !ballClock&#41;&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;/* Bounce ball on wall */&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// BALL_SHIFT = 2 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;ball_y &gt; &#40;LOWER_WALL -1&#41;&#41; ball_dy = -ball_dy;&nbsp; // LOWER_WALL =55 -- actual is at 56 -- so -- ball_y == LOWER_WALL - BALL_SHIFT&nbsp; --- ball_dy = -ball_dy
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;ball_y &lt; &#40;UPPER_WALL &#41;&#41; ball_dy = -ball_dy;&nbsp; // UPPER_WALL=7 actual is 8&nbsp; -- so --&nbsp; ball_y == UPPER_WALL + BALL_SHIFT&nbsp; --- ball_dy = -ball_dy&nbsp; 
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;/* Bounce ball on paddle */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;loose = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;paddle_bounce = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;pos = &#40;ball_x == LEFT_BOUNDARY&#41;?p1_pos&#58;p2_pos;&nbsp; // ball_x == LEFT_BOUNDARY ---- i.e 47
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;ball_x == LEFT_BOUNDARY || ball_x == &#40;RIGHT_BOUNDARY- 1&#41;&#41;&nbsp; &nbsp;// ball_x == LEFT_BOUNDARY ---- i.e 47&nbsp; ||&nbsp; ball_x == RIGHT_BOUNDARY ---- i.e 80
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;loose = 1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_y &lt;=pos&#41;&amp;&amp;&#40;ball_y &gt;= &#40;pos - TOP_OFFSET&#41;&#41;&#41; // &#40;ball_y &gt;=pos&#41;&amp;&amp;&#40;ball_y &lt;= &#40;pos + TOP_OFFSET&#41;&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// instead of pos+1 ---- pos + TOP_OFFSET&nbsp; --- TOP_OFFSET = 5 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ball_dx = -ball_dx;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//ball_dy = -2;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;loose = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;paddle_bounce = 1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ball is down and going up
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if &#40;&#40;ball_y == &#40;pos/*+BALL_SHIFT*/&#41;&#41; &amp;&amp; &#40;ball_dy == -BALL_SHIFT&#41;&#41;// going up // if &#40;&#40;ball_y == pos+BALL_SHIFT&#41;&amp;&amp; &#40;ball_dy == -BALL_SHIFT&#41;&#41;----- BALL_SHIFT = 2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ball_dx = -ball_dx;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ball_dy = -ball_dy;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;loose = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;paddle_bounce = 1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // ball is up and going down
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else if &#40;&#40;ball_y == &#40;pos-TOP_OFFSET/*-BALL_SHIFT*/&#41;&#41; &amp;&amp; ball_dy == BALL_SHIFT&#41;// comming down&nbsp; // if &#40;&#40;ball_y == pos - TOP_OFFSET + BALL_SHIFT&#41;&amp;&amp; &#40;ball_dy == -BALL_SHIFT&#41;&#41;----- BALL_SHIFT = 2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ball_dx = -ball_dx;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ball_dy = -ball_dy;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;loose = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;paddle_bounce = 1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;loose&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;cli&#40;&#41;; /* Disable interrupts */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;outp&#40;0x00, TCCR1B&#41;; /* turn off counter */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;outp&#40;0x00, TCCR0&#41;; /* turn off counter */
<br />

<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;ball_x == LEFT_BOUNDARY&#41;&nbsp; /* player 2 won */&nbsp; &nbsp;// ---------- ball_x == LEFT_BOUNDARY ---- i.e 47
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//display winner
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;display_winner&#40;2&#41;;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* Wait a little */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for &#40;i = 0; i &lt; 5000; i++&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for &#40;j = 0; j &lt; 1000; j++&#41; j=j;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;else /* player 1 won */&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// ------&nbsp; ball_x == RIGHT_BOUNDARY ---- i.e 80
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123; 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//display winner
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;display_winner&#40;1&#41;;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* Wait a little */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for &#40;i = 0; i &lt; 5000; i++&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;for &#40;j = 0; j &lt; 1000; j++&#41; j=j;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break_loop = TRUE;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;return;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;/* Change vertical speed of ball according to paddle speed */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;// here ball_dy can become -2,0,2
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;paddle_bounce&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_x == LEFT_BOUNDARY&#41;&amp;&amp;&#40;p1_up&#41;&amp;&amp;&#40;ball_dy &gt; -BALL_SHIFT&#41;&#41;&nbsp; &nbsp; &nbsp; ball_dy -=BALL_SHIFT; // &#40;ball_x == LEFT_BOUNDARY&#41;&amp;&amp;p1_up&amp;&amp;&#40;ball_dy &gt; -BALL_SHIFT&#41; ball_dy -=BALL_SHIFT;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_x == LEFT_BOUNDARY&#41;&amp;&amp;&#40;p1_dn&#41;&amp;&amp;&#40;ball_dy &lt; BALL_SHIFT&#41;&nbsp; &#41;&nbsp; &nbsp; &nbsp;ball_dy +=BALL_SHIFT; // &#40;ball_x == LEFT_BOUNDARY&#41;&amp;&amp;p1_dn&amp;&amp;&#40;ball_dy &lt; BALL_SHIFT&#41; ball_dy +=BALL_SHIFT;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_x == &#40;RIGHT_BOUNDARY-1&#41;&#41;&amp;&amp;&#40;p2_up&#41;&amp;&amp;&#40;ball_dy &gt; -BALL_SHIFT&#41;&#41; ball_dy -=BALL_SHIFT; // &#40;ball_x == RIGHT_BOUNDARY&#41;&amp;&amp;p2_up&amp;&amp;&#40;ball_dy &gt; -BALL_SHIFT&#41; ball_dy -=BALL_SHIFT;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_x == &#40;RIGHT_BOUNDARY-1&#41;&#41;&amp;&amp;&#40;p1_dn&#41;&amp;&amp;&#40;ball_dy &lt; BALL_SHIFT&#41;&#41;&nbsp; ball_dy +=BALL_SHIFT; // &#40;ball_x == RIGHT_BOUNDARY&#41;&amp;&amp;p1_dn&amp;&amp;&#40;ball_dy &lt; BALL_SHIFT&#41; ball_dy +=BALL_SHIFT;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;/* Wall bounce after paddle bounce */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_y &gt; &#40;LOWER_WALL - 1&#41;&#41; &amp;&amp; &#40;ball_dy == BALL_SHIFT&#41;&#41; ball_dy = -ball_dy; // LOWER_WALL is at 56 -- so -- &#40;ball_y == 56 - BALL_SHIFT &amp;&amp; ball_dy == -BALL_SHIFT &#41;&nbsp; --- ball_dy = -ball_dy
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if &#40;&#40;ball_y &lt;= &#40;UPPER_WALL &#41;&#41; &amp;&amp; &#40;ball_dy ==&nbsp; -BALL_SHIFT&#41;&#41; ball_dy = -ball_dy; // UPPER_WALL is at 7 -- so -- &#40;ball_y == 7 + BALL_SHIFT &amp;&amp; ball_dy == BALL_SHIFT &#41;&nbsp; &nbsp;--- ball_dy = -ball_dy&nbsp; 
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;/* Move ball */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ball_x += ball_dx;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;ball_y += ball_dy;
<br />
&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;redraw_needed = 1;
<br />
&#125;
<br />

<br />
/* output to LCD -- current position of ball &amp; paddle*/
<br />
ISR&#40;TIMER0_OVF_vect&#41; 
<br />
&#123;
<br />
&nbsp; &nbsp; &nbsp; &nbsp; // update data on LCD
<br />
&nbsp; &nbsp;interupt = 1;
<br />
&#125;
<br />

<br />
/* calculation related to Movement of ball &amp; switch pressed for paddle movement */
<br />
ISR&#40;TIMER1_COMPA_vect&#41; 
<br />
&#123;
<br />
&nbsp; &nbsp; &nbsp; &nbsp; // update local variables
<br />
&nbsp; &nbsp;interupt = 2;
<br />
&#125;
<br />

<br />
void main_pong&#40;void&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;// Initialise the timer &amp; start them
<br />
&nbsp; &nbsp;ioinit&#40;&#41;;
<br />

<br />
&nbsp; &nbsp;for&#40;;;&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // update data on LCD
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;interupt ==1&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* at declaration -- framebuffer_pos is zero -- 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;it comes here first time value inc to 1 ---- 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;then compare with 3*/
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;++framebuffer_pos &gt; 3&#41; framebuffer_pos = 1;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* Change requested output to LCD */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// Draw the paddle and ball images as per there relevant position 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;drawScene&#40;framebuffer_pos&#41;;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;/* Redraw scene during &quot;vertical retrace&quot; */
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;framebuffer_pos == 3 &amp;&amp; redraw_needed&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;drawScene&#40;ALL_SYMBOL&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;redraw_needed = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;interupt = 0;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />

<br />
&nbsp; &nbsp; &nbsp; &nbsp; // update local variables
<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;interupt == 2&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;if &#40;++speed_counter == speed_bumper&#41; &#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;speed_counter = 0;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//outw&#40;OCR1A, &#40;40000 / ++current_speed&#41; * 3&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;//if &#40;current_speed &gt; 100&#41; current_speed = 100;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// trace the position of ball as per s/w routine &amp; position of paddle as per button pressed 
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;timer_movement&#40;~inp&#40;SWITCH_PIN&#41;&#41;;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;interupt = 0;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;&nbsp; &nbsp;
<br />

<br />
&nbsp; &nbsp;&nbsp; &nbsp;if&#40;break_loop == TRUE&#41;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// clear the screan
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;ks0108ClearScreen&#40;&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// Initialize the global variables
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;variable_init&#40;&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// Draw the intial frame on LCD
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;drawframe&#40;&#41;;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;// Draw the all symbols
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;drawScene&#40;ALL_SYMBOL&#41;;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&nbsp; &nbsp;break;
<br />
&nbsp; &nbsp;&nbsp; &nbsp;&#125;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;&#125;
<br />
&#125;
<br />

<br />
int main&#40;void&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;unsigned char portB;
<br />

<br />
&nbsp; &nbsp;/* Set port B pin B0-3&nbsp; --- as input pin */
<br />
&nbsp; &nbsp;outp&#40;0x00, SWITCH_DDR&#41;;
<br />
&nbsp; &nbsp;//Activate pull up
<br />
&nbsp; &nbsp;outp&#40;0x0F, SWITCH_PORT&#41;;
<br />

<br />
&nbsp; &nbsp;// Initialize the LCD
<br />
&nbsp; &nbsp;ks0108Init&#40;0&#41;;
<br />
&nbsp; &nbsp;// Initialize the global variables
<br />
&nbsp; &nbsp;variable_init&#40;&#41;;
<br />
&nbsp; &nbsp;// Draw the intial frame on LCD
<br />
&nbsp; &nbsp;drawframe&#40;&#41;;
<br />
&nbsp; &nbsp;// Draw the all symbols
<br />
&nbsp; &nbsp;drawScene&#40;ALL_SYMBOL&#41;;
<br />

<br />
&nbsp; &nbsp;//while&#40;1&#41;;
<br />
&nbsp; &nbsp;
<br />
&nbsp; &nbsp;for &#40;;;&#41;
<br />
&nbsp; &nbsp;&#123;
<br />
&nbsp; &nbsp;//&nbsp; &nbsp;portB = ~inp&#40;SWITCH_PIN&#41;;
<br />
&nbsp; &nbsp;//&nbsp; &nbsp;if &#40;portB &amp; 0x03&#41; &#123; main_pong&#40;&#41;;&#125;&nbsp; // check for any of the right two buttons pressed
<br />
&nbsp; &nbsp;main_pong&#40;&#41;;
<br />
&nbsp; &nbsp;&#125;
<br />

<br />
&#125;</div>
<br />

<br />

<br />
two task are inside :---
<br />
<div class="codetitle"><b>Code:</b></div><div class="codecontent">void main_pong&#40;void&#41;
<br />
&#123;
<br />
&nbsp; &nbsp;// Initialise the timer &amp; start them
<br />
&nbsp; &nbsp;ioinit&#40;&#41;;
<br />

<br />
&nbsp; &nbsp;for&#40;;;&#41;</div>
<br />

<br />

<br />
So please suggest how to design my schedular that update of local variables related to position of ball &amp; paddle AND update of data on LCD happen in syncronisation ?<hr />
<b>code-by</b> - Oct 13, 2010 - 02:07 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
Hi!
<br />
Anybody have optimized code (library) for work with ks0108 for xmega?<hr />
<b>clawson</b> - Oct 13, 2010 - 02:10 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
But surely the interface uses nothing but IO? If that's the case take any mega based code and simply translate
<br />

<br />
PORTx -&gt; PORTx.OUT
<br />
PINx -&gt; PORTx.IN
<br />
DDRx -&gt; PORTx.DIR
<br />

<br />
(possibly remapping x to y while you are at it)<hr />
<b>code-by</b> - Oct 14, 2010 - 07:19 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
So there nothing to optimize in code when translate from mega to xMega?<hr />
<b>clawson</b> - Oct 14, 2010 - 11:09 AM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
<div class="quotetitle"><b>Quote:</b></div><div class="quotecontent">
<br />
So there nothing to optimize in code when translate from mega to xMega?
<br />
</div>
<br />
Not if it's only doing IO. I guess that ultimately you could explore setting up a frame buffer in EBI attached RAM and DMA'ing it from their to the LCD data port but given that STN LCD generally have something like a 200ms switching time it doesn't make much sense to try and update them too quickly or the display will just look blurry.<hr />
<b>code-by</b> - Oct 18, 2010 - 02:11 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
Can somebody attach simple working project xmega with LCD 128x64 with ks0108? (avrstudio or codevision). thank<hr />
<b>JohanEkdahl</b> - Oct 18, 2010 - 05:41 PM<br />
<b>Post subject: </b>RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE: Re: RE:<hr class="sep"/>
Perhaps if you ask Ali really nicely...
<br />

<br />
<!-- m --><a href="http://www.avrfreaks.net/index.php?name=PNphpBB2&amp;file=viewtopic&amp;p=755447#755447" target="_blank">http://www.avrfreaks.net/index.php?name ... 447#755447</a><!-- m --><hr />
<div align="center">All times are GMT + 1 Hour<br />
Powered by <a style="text-decoration:none;" href="http://www.pnphpbb.com" target="_blank"><font color="ff6600"><b><i>PN</i></b></font><font color="0001f0"><b>phpBB2</b></font></a>&nbsp;&copy; 2003-2006&nbsp;The PNphpBB Group<br/><a href="./modules/PNphpBB2/docs/copyrite.html" onclick="window.open('./modules/PNphpBB2/docs/copyrite.html', '_pnphpbb2_credits', 'HEIGHT=250,WIDTH=450,scrollbars=yes');return false;" target="_pnphpbb2_credits">Credits</a> </div>
</body>
</html>

